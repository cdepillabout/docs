#!/bin/bash 

# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.

# Here is another way to do this:
# [ -z "$PS1" ] && return 
if [[ $- != *i* || "$TERM" == "dumb" || "$0" != *bash ]] ; then
	# Shell is non-interactive or shell is not bash.  Be done now!
    PROMPT_COMMAND=''
    return
fi

# this gets us some functions and variables needed by various programs
if [[ -e "${HOME}/docs/code/library.sh" ]] ; then
	source "${HOME}/docs/code/library.sh"
fi

# source the global /etc/profile
if [[ -f "/etc/profile" ]] ; then
	source "/etc/profile"
fi

# Enable colors for ls, etc.
if [ -x "`get_location_of_file dircolors`" ]; then
	eval "`dircolors -b`"
elif [[ -f /etc/DIR_COLORS ]]; then
	eval `dircolors -b /etc/DIR_COLORS`
elif [[ -f ~/.dir_colors ]]; then
	eval `dircolors -b ~/.dir_colors`
fi

if [[ "$(uname)" == "Linux" || "$(uname -o)" == "Cygwin" ]]; then
	alias ls="ls --color=auto"
	alias grep="grep --color=auto"
	alias xgrep="xgrep --color=auto"
elif [[ "$(uname)" == "FreeBSD" ]]; then
	export CLICOLOR=1
	alias grep="grep --color=auto"
elif [[ "$(uname)" == "OpenBSD" ]]; then
	# We use the gnu versions of ls and grep
	# so that we can get color.
	# We must install these programs first.
	alias ls="gls --color=auto"
	alias grep="ggrep --color=auto"

	# This is so that root doesn't take all the bash
	# settings from our user when su'ing.
	# Root uses ksh by default, not bash.
	alias su="su -l"

	# we want vim and other commands to use color
	# when running under X
	if [[ "$TERM" == xterm* ]]; then
		export TERM="xterm-color"
	fi
fi

alias lsr="ls -rt"

# less interprets color escape sequences instead of
# just printing them to the screen
alias less="less -R"


# this is so less will open .gz and other similar files
# instead of just displaying garbage
less_pipe_location=`get_correct_filename_from_choices "lesspipe" "lesspipe.sh"`
export LESSOPEN="| ${less_pipe_location} %s"

# strict umask
umask 0077

# have bash check if an option is supported and set it if it is.
# There are many options (like globstar and autocd) that are only
# available in bash 4+.
shopt_check_and_set() {
	option="$1"
	if [ -n "$(shopt -p | grep "${option}")" ] ; 
	then
		shopt -s "${option}"
	fi

}

# make bash check the window size after each command
shopt_check_and_set "checkwinsize"

# automatically change directory if you just type the directory on the command line.  
shopt_check_and_set "autocd"

# be able to use ** to match all subdirs
shopt_check_and_set "globstar"

# this escape sequence is used so that screen can set
# the window title
case $TERM in
	xterm*|rxvt*|Eterm)
		if [ -n "$ROXTERM_NUM" ] ; then
			SCREEN_OR_XTERM_PS1_ESCAPE='\[\033]0;bash\007\]'
		else
			SCREEN_OR_XTERM_PS1_ESCAPE='\[\033]0;${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\007\]'
		fi
		;;
	screen)
		SCREEN_OR_XTERM_PS1_ESCAPE='\[\033k\033\\\]'
		;;
	*)
		SCREEN_OR_XTERM_PS1_ESCAPE=''
		;;
esac


# colors for using in PS1
PS1_black="\[\033[01;30m\]"
PS1_red="\[\033[01;31m\]"
PS1_green="\[\033[01;32m\]"
PS1_yellow="\[\033[01;33m\]"
PS1_blue="\[\033[01;34m\]"
PS1_magenta="\[\033[01;35m\]"
PS1_cyan="\[\033[01;36m\]"
PS1_white="\[\033[01;37m\]"

PS1_normal_text="\[\033[00;00m\]"

PS1_git_branch_color="${PS1_yellow}"
PS1_mercurial_branch_color="${PS1_magenta}"


# put the git branch in our prompt
get_git_or_hg_branch()
{
	# try to see if this is a git branch first
	git_branch=`git branch 2>/dev/null | grep "\*" | sed -e "s/^\* //"`
	if [ -n "${git_branch}" ] ; then
		echo -n "${PS1_git_branch_color}${git_branch} "
		return
	fi
	
	# now try to see if it is a mercurial branch
	mercurial_branch=`hg branch 2>/dev/null`
	if [ -n "${mercurial_branch}" ] ; then
		echo -n "${PS1_mercurial_branch_color}${mercurial_branch} "
		return
	fi
}


PS1_username="${PS1_green}\u"
PS1_at="${PS1_blue}@"
PS1_hostname="${PS1_green}\h"
PS1_workingdir="${PS1_blue}\w"
# source code management dir
PS1_scmdir=""
# a '$' if we are a normal user and a '#' if we are root
PS1_dollar_or_pound="${PS1_blue}\\\$"

# we want a different color hostname if we 
# are on a remote connection
if [ -n "${SSH_CLIENT}" -a -n "${SSH_CONNECTION}" -a -n "${SSH_TTY}" ] ; then
	PS1_hostname="${PS1_magenta}\h"
fi

# this is the command we want to run before every
# command prompt.  it sets our scmdir and colors for us.
# this is for a normal user.
bash_prompt_normal() {
	export PS1="${PS1_username}${PS1_at}${PS1_hostname} ${PS1_workingdir} $(get_git_or_hg_branch)"${SCREEN_OR_XTERM_PS1_ESCAPE}"${PS1_dollar_or_pound} ${PS1_normal_text}"
}
# this is for the root user
bash_prompt_root() {
	export PS1="${PS1_username}${PS1_at}${PS1_hostname} ${PS1_workingdir} ${PS1_dollar_or_pound} ${PS1_normal_text}"
}


# we want a slightly different prompt if we are root
if [[ $EUID -eq 0 ]] ; then
	PS1_username="${PS1_red}\u"
	PS1_dollar_or_pound="${PS1_red}\\\$"
	export PROMPT_COMMAND=bash_prompt_root
else
	export PROMPT_COMMAND=bash_prompt_normal
fi

# run the prompt command once so we make sure PS1 is set
$PROMPT_COMMAND


# get the autojump stuff in our prompt if it's available and we're not root
if [[ $EUID -ne 0 ]] ; then
	if [ -e "/etc/profile.d/autojump.bash" ] ;  then
		source "/etc/profile.d/autojump.bash"
	fi
fi

# set my locale for man
alias man='LC_ALL="C" LANG="C" man'

# make emacs always open in non-graphical mode
#alias emacs='emacs -nw '

# make vim open with the servername as "vimserver"
#alias vim='vim --servername "vimserver" '

# make sure vim opens up tabs for multiple files
alias vim='vim -p '
alias gvim='gvim -p '

# make command for opening files on an already open vim browser
#alias rvim='vim --servername "vimserver" --remote-tab-silent '
alias rgvim='gvim --remote-tab-silent '

# make sure java runs in server mode and with assertions enabled
alias java='java -server -ea '

# a good rsync command that will work as a `cp` replacemnt.
# When using rsync to copy directories, make sure not to put a
# "/" after the SRC directory name, otherwise everything in
# the directory will be copied, but not the directory itself.
alias rsyncp='rsync -a -P '

# this is a safe version of dd.  It doesn't overwrite the output file.
alias dd='safe-dd '

# git aliases
alias gadd='git add '
alias gba='git branch -a '
alias gb='git branch '
alias gcam='git commit -a -m '
alias gcm='git commit -m '
alias gco='git checkout '
alias gdcf='git diff-changed-files '
alias gdff='git diff '
alias gdiff='git diff '
alias gf='git fetch '
alias gfa='git fetch-all '
#alias gitka='gitk HEAD ORIG_HEAD '
alias gitka='gitk HEAD HEAD@{1} '
#alias gitkam='gitk HEAD ORIG_HEAD origin/master '
alias gitkam='gitk HEAD HEAD@{1} origin/master '
alias glg='git log '
alias glog='git log '
alias gpo='git push origin '
alias gpoh='git push origin HEAD '
alias gpsh='git push '
alias gst='git status '

# screen automatically connects to a running session
alias screen='screen -R '

# make sure Anki 2 uses the ~/.anki2/ directory to store the decks and its config files
# instead of the default (which is ~/Anki/).
alias anki="anki --base=\"${HOME}/.anki2\""

# I hate when systemd uses a pager
alias systemctl="systemctl --no-pager "
alias journalctl="journalctl --no-pager "

# SSH Get Auth Sock.
# This is a command to automatically update the SSH_AUTH_SOCK env var.
# (This is needed when connecting to a previously running
# screen session, since the SSH_AUTH_SOCK variable will be the 
# previous one we were using.  We need a new updated one
# for this new connection.)
function ssh-gas ()
{
	local VERBOSE=""

	for arg in "$@" ; do
		if [[ "$arg" == '-h' || "$arg" == "--help" ]] ; then
			echo "Usage: ${FUNCNAME[0]} [-h] [-v]"
			echo "Set SSH_AUTH_SOCK environment variable."
			return
		elif [[ "$arg" == '-v' || "$arg" == "--verbose" ]] ; then
			VERBOSE=1
		else
			die "Unknown argument \"${arg}\""
		fi
	done

	# get all the existing agent files
	shopt -q extglob
	local SHOPT_PREV_VAL="$?"
	shopt -s extglob
	local agent_files="$(ls -rt /tmp/ssh-+([A-Za-z0-9 ])/agent.+([0-9]) 2>/dev/null)"
	if  [ "$SHOPT_PREV_VAL" -eq "1" ] ; then
		shopt -u extglob
	fi

	# make sure there actually are auth socks to get
	if [ -z "$agent_files" ] ; then
		echo "ERROR: no auth sock available" 
		return
	fi

	# get the most recently added ssh auth sock
	local auth_sock="$(echo "$agent_files" | tail -1)"
	[ "$VERBOSE" ] && echo "using auth sock: $auth_sock"
	export SSH_AUTH_SOCK="$auth_sock"
}

# these are aliases for cd'ing and ls'ing at the same time
function cd_and_ls_func(){ 
	cd "$@" && ls
}
function cd_and_lsl_func(){ 
	cd "$@" && ls -l
}
function autojump_func() { 
	new_path="$(autojump $@)"
	if [ -n "$new_path" ]; then 
		echo -e "\\033[31m${new_path}\\033[0m"
		cd "$new_path"
	fi 
}
function autojump_and_ls_func(){ 
	new_path="$(autojump $@)"
	if [ -n "$new_path" ]; then 
		echo -e "\\033[31m${new_path}\\033[0m"
		cd "$new_path"
		ls
	fi 
}
function autojump_and_lsl_func(){ 
	new_path="$(autojump $@)"
	if [ -n "$new_path" ]; then 
		echo -e "\\033[31m${new_path}\\033[0m"
		cd "$new_path"
		ls -l
	fi 
}
alias c='cd_and_ls_func '
alias cl='cd_and_lsl_func '
alias jd='autojump_func '
alias j='autojump_and_ls_func '
alias jl='autojump_and_lsl_func '


# add a command for updating pacman mirror list
function reflector-update-mirrorlist() {
	if [[ $EUID -ne 0 ]] ; then
		echo "ERROR! Cannot update the mirror list if you are not root." >&2
		return 1
	fi

	mirrorlist="$(/usr/bin/reflector -l 10 --sort rate -c "United States" -c "Japan" -c "Korea")"

	if [ -z "$mirrorlist" ] ; then
		echo "ERROR! Could not get an updated mirrorlist." >&2
		return 1
	fi

	if [ -f "/etc/pacman.d/mirrorlist" ] ; then
		echo "Moving old mirrorlist to /etc/pacman.d/mirrorlist.bak..."
		mv /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak
	fi

	# now move our new mirror list into place
	echo "$mirrorlist" > /etc/pacman.d/mirrorlist

	chmod 0644 /etc/pacman.d/mirrorlist

	# output our new mirrorlist to the screen
	echo "New mirrorlist:"
	echo "---------------------------------------------"
	echo "$mirrorlist" #> /etc/pacman.d/mirrorlist
	echo "---------------------------------------------"
	echo "Done."
	return 0
}

# don't record duplicate items in history or 
# lines starting with a space ('$  ls -la')
export HISTCONTROL='ignoreboth'

# I don't want a git pager
export GIT_PAGER=''

# add /sbin, /usr/sbin, and /usr/local/sbin to path if they are not in it
add_to_path PATH "/sbin"
add_to_path PATH "/usr/sbin"
add_to_path PATH "/usr/local/sbin"

# add my program directory
add_to_path PATH "$HOME/docs/code/bin" 

# add classpath for java
add_to_path_nocheck CLASSPATH "/usr/share/junit-4/lib/junit.jar"
add_to_path_nocheck CLASSPATH "/usr/share/hamcrest-core/lib/hamcrest-core.jar"


# add default browser
export BROWSER=`get_correct_filename_from_choices "firefox-bin" "firefox"`

export EDITOR=`get_correct_filename_from_choices "/usr/bin/vim" "/usr/local/bin/vim"`

# XDG Base Directory Specification
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DESKTOP_DIR="$HOME"
export XDG_DOWNLOAD_DIR="$HOME"

# Set colors for GCC (Only works on >=4.9)
export GCC_COLORS="error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"

# We xauth stuff to be set correctly if we are root.
if [[ $EUID -eq 0 ]] ; then
	# make sure we can actually access xauth functionality
	if [ -f "/usr/bin/xauth" ] ; then
		# make sure we didn't just log in as root
		if [ "$(id -u -n)" != "$USER" ] ; then
			# Make sure the user actually has an .Xauthority file setup
			# that we can use.
			if [ -f "/home/$USER/.Xauthority" ] ; then
				export XAUTHORITY="/home/$USER/.Xauthority"
			fi
		fi
	fi
fi

# add the filesystem from the home directory to the PATH
add_to_path PATH "$HOME/filesystem/bin"

# if we have our filesystem, then make sure the python path
# is set correctly within it
for f in $HOME/filesystem/lib/python*
do
	add_to_path PYTHONPATH "${f}/site-packages/"
done


# bash completions (only used if we are not root)
if [[ $EUID -ne 0 ]] ; then
	# load bash completions if we have them
	filesystem_bash_completion_script="/usr/share/bash-completion/bash_completion"
	[ -r "$filesystem_bash_completion_script" ] && . "$filesystem_bash_completion_script"

	# load local bash completions
	local_bash_completion_dir="$HOME/filesystem/etc/bash_completion.d"
	if [ -d "$local_bash_completion_dir" ] ; then
		if [ -f "$filesystem_bash_completion_script" ] ; then
			# this have command gets unset at the end of /etc/bash_completion, 
			#so we need to put it back in
			have()
			{
				unset -v have
				# Completions for system administrator commands are installed as well in
				# case completion is attempted via `sudo command ...'.
				PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin type $1 &>/dev/null &&
					have="yes"
			}

			for f in $(LC_ALL=C command ls "$local_bash_completion_dir"); do
				source "${local_bash_completion_dir}/${f}"
			done
		fi
	fi
fi

# source the local rc file with local commands
if [ -f "$HOME/.local-bashrc" ]
then
	source "${HOME}/.local-bashrc"
fi
