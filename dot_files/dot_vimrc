
" If there is a global vimrc, first read it.  This is used on Debian-based
" distros that have a global vimrc. The filepath for addons is specified in
" this global file.  Addons are then enabled and disabled with the
" vim-addon-manager command.  This global file resets some of my settings
" below, so this needs to be done before anything else is done.
if filereadable("/etc/vim/vimrc") " debian
	source /etc/vim/vimrc
endif
if filereadable("/etc/vimrc") " arch linux
	source /etc/vimrc
endif

set nocompatible		" Explicitly turn off compatibility mode
filetype off

" This has to come first because it resets all highlighting.
set background=dark
colorscheme darkblue
"colorscheme default
"colorscheme delek
"colorscheme desert
"colorscheme torte

" let my leader key be space instead of \
" This needs to be set as soon as possible because
" things mapped with <Leader> are mapped with the
" current leader and don't get changed to be a new
" leader when you set a new leader. So we need to
" set this as soon as possible so that the leader
" gets mapped correctly when we are setting mappings
" that use the leader.
let mapleader = " "

" load vundles if we have any
if isdirectory(expand("~/.vim/bundle/vundle/.git"))
	set runtimepath+=~/.vim/bundle/vundle/
	call vundle#rc()

	" let Vundle manage Vundle
	" required!
	Bundle 'gmarik/vundle'
	" Brief help
	" :BundleList          - list configured bundles
	" :BundleInstall(!)    - install (update) bundles
	" :BundleSearch(!) foo - search (or refresh cache first) for foo
	" :BundleClean(!)      - confirm (or auto-approve) removal of unused bundles
	"
	" see :h vundle for more details or wiki for FAQ
	" NOTE: comments after Bundle commands are not allowed.


	" These are the types of repos you add with Vundle:
	" (1) original repos on GitHub
	"Bundle 'tpope/vim-rails.git'
	" (2) vim-scripts repos
	"Bundle 'FuzzyFinder'
	" (3) non-GitHub repos
	"Bundle 'git://git.wincent.com/command-t.git'
	" (4) Git repos on your local machine (i.e. when working on your own plugin)
	"Bundle 'file:///Users/gmarik/path/to/plugin'


	" Here are some more good haskell-related plugins
	" http://blog.mno2.org/blog/2011/11/17/vim-plugins-for-haskell-programmers/
	" http://comments.gmane.org/gmane.comp.lang.haskell.cafe/108152?set_cite=hide
	" http://haskelllive.com/environment.html


	" :help syntastic to get more help
	" To toggle between active/passive type checking we can enable the following key bindings
	"map <silent> <Leader>e :Errors<CR>
	"map <Leader>s :SyntasticToggleMode<CR>
	Bundle 'scrooloose/syntastic'
	" Always populate the location list even if :Errors is not run.
	" (This is disabled by default to reduce conflicts with other plugins.)
	" With this enabled, you can jump to different errors
	let g:syntastic_always_populate_loc_list = 1
	" don't use the :sign interface to mark errors
	"let g:syntastic_enable_signs = 0

	" This is used by ghcmod-vim for something.
	if version >= 701
		Bundle 'Shougo/vimproc'
		if isdirectory(expand("~/.vim/bundle/vimproc/.git")) &&
				\ !(filereadable(expand("~/.vim/bundle/vimproc/autoload/vimproc_unix.so")) ||
				\   filereadable(expand("~/.vim/bundle/vimproc/autoload/vimproc_linux64.so")))
			echo "You must run `(cd \"$HOME/.vim/bundle/vimproc/\" && make)` in order to install vimproc (for ghc-mod)."
		endif
	endif

	" Must `cabal install ghc-mod` to be able to use this.
	" :GhcModType		- Show the type of an expression (can be used multiple
	"					  times to show bigger and bigger expressions)
	" :GhcModTypeClear  - Clear subexpression's highlight
	" :GhcModCheck      - Show compiler error/warnings in quickfix window
	" :GhcModLint       - Show suggestions by ghc-mod lint
	" :GhcModInfo       - Show the type of an expression
	" :GhcModTypeInsert - Insert the type of a function
	Bundle 'eagletmt/ghcmod-vim'
	let g:ghcmod_type_highlight='ghcmodType'
	" TODO: Only use these when in haskell mode...
	map <Leader>gt :GhcModType<CR>
	map <Leader>gc :GhcModTypeClear<CR>
	map <Leader>gi :GhcModTypeInsert<CR>
	map <Leader>gn :GhcModInfo<CR>


	" Use neocomplete (this is supposed to work with neco-ghc for haskell
	" completion, but it doesn't really look like it does anything)
	if version >= 704 && has("if_lua")
		Bundle 'Shougo/neocomplete'
	endif

	" Must `cabal install ghc-mod` to be able to use this.
	" Use omnicompletion for haskell.
	" See :help compl-omni for details on omni-completion.
	" Enable with :setlocal omnifunc=necoghc#omnifunc (set below...)
	" Can be used with Ctrl-X Ctrl-O
	Bundle 'eagletmt/neco-ghc'
	autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

	" Must run `cabal install hoogle && hoogle data` before using.
	" Look up things through hoogle.
	" See :help hoogle for help.
	" :Hoogle         - run hoogle on the word under the cursor
	Bundle 'Twinside/vim-hoogle'

	" Must `cabal install hdevtools` to be able to use this.
	" This is basically the same as ghc-mod
	" :HdevtoolsInfo	- get info about a type
	" :HdevtoolsType	- get short type information
	"Bundle 'bitc/vim-hdevtools'

	" You can use keys like _i to automatically import stuff that
	" has not yet been imported.
	" But before you use this functionality, you must run :ExportDocIndex
	Bundle 'lukerandall/haskellmode-vim'
	let g:haddock_browser="/usr/bin/firefox"
	let g:haddock_indexfiledir=$HOME . "/.vim/"

	" must `cabal install hlint` to be able to use hlint stuff.
	" This does some cool things with syntax highlighting for you.
	" It also does some really nice folding for us.
	" :HLint	-- run file through hlint
	Bundle 'dag/vim2hs'
	" disable all conceals, including the simple ones like
	" lambda and composition
	let g:haskell_conceal = 0
	" disable concealing of "enumerations": commatized lists like
	" deriving clauses and LANGUAGE pragmas,
	" otherwise collapsed into a single ellipsis
	let g:haskell_conceal_enumerations = 0
	" Also disable conceal for jmacro.
	let g:jmacro_conceal = 0

	" EasyMotion.
	Bundle 'Lokaltog/vim-easymotion'

	" This uses :sign to show changed areas of code a la `git diff`.
	" Haven't really looked into this one yet either...
	"Bundle 'mhinz/vim-signify'

	" Nerdtree.  Need to enable this and make some mappings...
	Bundle 'scrooloose/nerdtree'
	nnoremap <F3> :NERDTreeToggle<CR>

	" Use multiple cursors just like Sublime text.  I almost feel
	" like this isn't needed because macros are so convenient...
	"Bundle 'terryma/vim-multiple-cursors'

	" Get more commands for doing things to surrounding text.
	Bundle 'tpope/vim-surround'

	" This allows to write really short html.
	" You can convert the sparkup syntax to html with
	" Ctrl-E in insert mode, and then move to the next
	" empty element with Ctrl-N in insert mode.
	" Some examples of syntax are below:
	" https://github.com/rstacruz/sparkup
	" Other examples of syntax:
	" http://code.google.com/p/zen-coding/
	Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}

	" nicer statusline
	" This seems like it would be nice, but I would have to configure it
	" not to look ugly.  Also, it doesn't seem like it would be too helpful
	" without the fugitive git plugin.
	"Bundle 'bling/vim-airline'

	" Shows git-diff stuff in the sign column and allows you to stage/revert
	" hunks.
	" :GitGutterDisable	             -- disable git gutter
	" :GitGutterLineHighlightsToggle -- toggle whether lines are highlighted
	" ]c and [c                      -- jump to next hunk
	" <Leader>hs                     -- stage the hunk
	" <Leader>hr                     -- revert the hunk
	" <Leader>hp                     -- preview the hunk?
	" These two are needed if gitgutter becomes slow.
	" let g:gitgutter_realtime = 0   -- Make it so that the gutter is not updated in realtime.
	" let g:gitgutter_eager = 0      -- Make it so that the gutter is not updated when switching tabs.
	Bundle 'airblade/vim-gitgutter'
	" git gutter needs to use raw grep because i have colors turned on in my grep
	let g:gitgutter_escape_grep = 1

	" Does various git commands.
	Bundle 'tpope/vim-fugitive'

	" Vim plugin for browsing tags of source code.  It opens up a sidebar that
	" displays ctags-generated gtags of the current file.
	if version >= 701
		Bundle 'majutsushi/tagbar'
		" F2 for turning on and off tag list
		nnoremap <F2> :TagbarToggle<CR>
		let g:tagbar_type_scala = {
			\ 'ctagstype' : 'Scala',
			\ 'kinds'     : [
				\ 'p:packages:1',
				\ 'V:values',
				\ 'v:variables',
				\ 'T:types',
				\ 't:traits',
				\ 'o:objects',
				\ 'a:aclasses',
				\ 'c:classes',
				\ 'r:cclasses',
				\ 'm:methods'
			\ ]
		\ }
	endif

	" Syntax files for puppet.
	Bundle 'puppetlabs/puppet-syntax-vim'

	" Scala syntax
	Bundle 'derekwyatt/vim-scala'

	" Rainbow parentheses
	Bundle 'kien/rainbow_parentheses.vim'
	let g:rbpt_colorpairs = [
	    \ ['darkred',     'DarkOrchid3'],
	    \ ['darkgray',    'DarkOrchid3'],
	    \ ['darkmagenta', 'DarkOrchid3'],
	    \ ['darkgreen',   'RoyalBlue3'],
	    \ ['red',         'firebrick3'],
	    \ ['brown',       'RoyalBlue3'],
	    \ ['darkmagenta', 'DarkOrchid3'],
	    \ ['gray',        'RoyalBlue3'],
	    \ ['darkcyan',    'SeaGreen3'],
	    \ ['darkblue',    'SeaGreen3'],
	    \ ['darkred',     'SeaGreen3'],
	    \ ['darkgreen',   'firebrick3'],
	    \ ['darkcyan',    'RoyalBlue3'],
	    \ ['blue',        'firebrick3'],
	    \ ['brown',       'firebrick3'],
	    \ ['darkmagenta', 'DarkOrchid3'],
	    \ ['darkgreen',   'RoyalBlue3'],
	    \ ['red',         'firebrick3'],
	    \ ]
	autocmd VimEnter * if exists(":RainbowParenthesesActivate") |
		\ exec ":RainbowParenthesesActivate" | endif
	autocmd BufEnter * if exists(":RainbowParenthesesLoadRound") |
		\ exec ":RainbowParenthesesLoadRound" | endif
	autocmd BufEnter * if exists(":RainbowParenthesesLoadSquare") |
		\ exec ":RainbowParenthesesLoadSquare" | endif
	autocmd BufEnter * if exists(":RainbowParenthesesLoadBraces") |
		\ exec ":RainbowParenthesesLoadBraces" | endif
	"autocmd BufEnter * if exists(":RainbowParenthesesLoadChevrons") |
	"	\ exec ":RainbowParenthesesLoadChevrons" | endif

	" This adds mappings like the following:
	" [a, ]a                :previous, :next
	" [b, ]b                :bprevious, :bnext
	" [l, ]l                :lprevious, :lnext
	" [q, ]q                :cprevious, :cnext
	" [<Space>, ]<Space>    add a blank line above or below the cursor
	Bundle 'tpope/vim-unimpaired'

	" This adds the key command 'gcc' to comment out the
	" current line.  It also adds the command 'gc' in visual
	" mode to comment out a block.
	" In order to set the comment character for a specific filetype,
	" just use an autocommand like the following.
	" autocmd FileType apache set commentstring=#\ %s
	Bundle 'tpope/vim-commentary'
	autocmd FileType puppet set commentstring=#%s

	" This adds text selection/movement commands for working
	" with similarly indented blocks of code.
	" It depends on the following plugin:
	"Bundle 'kana/vim-textobj-user'
	" Here is the plugin itself:
	"Bundle 'kana/vim-textobj-indent'

endif

" make sure that ~/.vim is first in the runtimepath.  Commands like zg will
" store files by default in the first entry in the runtime path.
" (In this case, it will store the default spell file in a file like
" spell/en.utf-8.spl in the first entry in runtimepath.)
let &runtimepath=("~/.vim/," . &runtimepath)

" I am moving syntax on down to here because putting it above was
" causing puppetlabs/puppet-syntax-vim to not pickup the ftdetect
" settings for puppet files.  But this causes all highlights that
" have been defined to be undefined, so all of my highlights have
" to go below.
syntax on
filetype plugin indent on

set fileencodings=utf-8
setglobal fileencoding=utf-8
set encoding=utf-8
set ttymouse=xterm2		" mouse scrolling in vim
set mouse=a
set foldenable
set tabstop=4			" 4-space tab indent width
set shiftwidth=4		" allows you to use < and > to indent/unindent blocks
set softtabstop=4		" see multiple space characters as a tab
set shiftround			" Indent to nearest tab stop
set autoindent			" carries over previous indent to the next line
set smarttab			" A tab infront of a line inserts spaces or tabs according to expandtab
set autoread			" when file detected changed outside of Vim, automatically read it again

if version <= 702
	set switchbuf=usetab,useopen
else
	set switchbuf=usetab,useopen,newtab
endif

" Tell vim to remember certain things when we exit
"  '100 : marks will be remembered for up to 100 previously edited files
"  "100 : will save up to 100 lines for each register
"  :20 : up to 20 lines of command-line history will be remembered
"  % : saves and restores the buffer list
"  n... : where to save the viminfo files
set viminfo='100,\"100,:20,%,n~/.viminfo

set wildmode=list:longest	" When autocompleting things, do it like the shell
set wildmenu				" Autocomplete things on the menu?
set scrolloff=3				" Scroll when the cursor is 3 lines from top or bottom
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set ruler					" know how far you are in a file
set enc=utf-8
set fenc=utf-8
set backspace=indent,eol,start	" make sure backspace works correctly

set guifont=Bitstream\ Vera\ Sans\ Mono\ 14 "font names to be used in gui

" this combination works out well to only apply case to searches
" if there is an uppercase letter in your search string
set ignorecase
set smartcase

" this uses the tags file if it is found anywhere above this directory
" in a file called tags.  If it can't find it, it then looks for a file
" called build/tags in any directory above this one
set tags+=tags;$HOME,build/tags;$HOME

" always show a tabline
set showtabline=2

" set the maximum number of files you can open in tabs
if &tabpagemax < 50
	  set tabpagemax=50
endif


" Give us some additional colors for highlighting haskell code.
" TODO: Really what I want is for types to be bright green and keywords to be
" the darker blue color...
highlight hsType ctermfg=blue
highlight hsKeyword ctermfg=brown

" This lets ghcmod give us nice yellow background highlighting when
" looking at an expression's type.
highlight ghcmodType ctermfg=0 ctermbg=yellow guifg=black guibg=yellow

" highlight tab line differently
highlight TabLine term=bold,reverse cterm=bold ctermfg=black ctermbg=white
highlight TabLineFill term=bold,reverse cterm=bold ctermfg=white ctermbg=white
highlight TabLineSel term=reverse ctermfg=white ctermbg=lightblue

" highlight the popup menu a little differently
highlight PmenuSel ctermbg=lightblue

" make sure the normal background is black
highlight Normal guibg=black

" Make sure Special items are not Red.  The scala syntax highlighting makes
" objects (strings that start with a captial letter) this "Special" value, and
" it makes them dark red.  It makes them look like comments.  This makes them
" a brighter red so they stand out from comments.
highlight Special ctermfg=red

" settings specifically for java from
" http://vimdoc.sourceforge.net/htmldoc/syntax.html
let java_highlight_java_lang_ids=1
let java_highlight_all=1
"let java_highlight_functions="style"
"let java_allow_cpp_keywords=1

" make sure xml files are folded
let g:xml_syntax_folding=1

" make sure javascript files are folded
"let g:javaScript_fold=1

" do php folding
let g:php_folding=2

" use F5 for turning off and on hlsearch,
" in both input mode (imap?) and command mode (map?)
map <F5> :set hlsearch!<CR>
imap <F5> <ESC>:set hlsearch!<CR>a

" use F6 for turning on and off paste mode
map <F6> :set paste!<CR>
imap <F6> <ESC>:set paste!<CR>a

" use F7 for turning on and off list mode
map <F7> :set list!<CR>
imap <F7> <ESC>:set list!<CR>a

" use <C-h> and <C-l> to go forward and backward in tabs
" nnoremap just makes a normal mode mapping
nnoremap <C-h> gT
nnoremap <C-l> gt


map <silent> <C-u> :let b:new_tab_number = tabpagenr() \| exec ":tabm " . b:new_tab_number \| unlet b:new_tab_number<CR>
map <silent> <C-y> :let b:new_tab_number = tabpagenr() - 2 \| if (b:new_tab_number < 0) \| let b:new_tab_number = 0 \| endif \| exec ":tabm " . b:new_tab_number \| unlet b:new_tab_number<CR>
"nnoremap <C-S-h> :let b:current_tab_number = tabpagenr()

" got to tab number (really only for gvim)
nnoremap <A-1> 1gt
nnoremap <A-2> 2gt
nnoremap <A-3> 3gt
nnoremap <A-4> 4gt
nnoremap <A-5> 5gt
nnoremap <A-6> 6gt
nnoremap <A-7> 7gt
nnoremap <A-8> 8gt
nnoremap <A-9> 9gt
nnoremap <A-0> 10gt

" use <C-Enter> to jump to the tag under the cursor in a new tab.
" Also check out "<C-w>T", it takes a split screen off to a new tab.
" THIS DOESN'T WORK FOR SOME REASON:
"nnoremap <C-{> <C-w><C-]><C-w>T
" this can also be something like this:
map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap sudow w !sudo tee > /dev/null %

" Q is used to mess with macros.  q is used to close tabs/windows.
" Q's original function is to go into EX-mode.  I almost never want
" to go to EX mode, so I made this mapping.
noremap Q q
map q :q<CR>

" this is needed for running taglist in screen:
let Tlist_Inc_Winwidth = 0

" use CTRL-s for saving
" this doesn't work...
"nmap <c-s> :w<CR>
"imap <c-s> <Esc>:w<CR>a

" in input mode, what about we try using jj as escape
inoremap jj <Esc>

function! Resize(dir)
	" TODO: could also do something like this for horizontal split screen
	let above = 0
	let below = 0

	let this = winnr()

	if a:dir == 'C-J' || a:dir == 'C-K'
		execute "normal \<c-w>k"
		let up = winnr()
		if up != this
			execute "normal \<c-w>j"
			let above = 1
		endif

		execute "normal \<c-w>j"
		let down = winnr()
		if down != this
			execute "normal \<c-w>k"
			let below = 1
		endif

	"elseif '>' == a:dir || '<' == a:dir
	"	execute "normal \<c-w>h"
	"	let left = winnr()
	"	if left != this
	"		execute "normal \<c-w>l"
	"		let x = 'right'
	"	else
	"		let x = 'left'
	"	endif
	else
		echo "oops. check your ~/.vimrc here."
		return
	endif

	if ( ('C-J' == a:dir || 'C-K' == a:dir) && above == 0 && below == 0 )
		" this is the only window on the screen
		return

	elseif ('C-J' == a:dir && above == 1 && below == 0)
		" there are no windows below this on the screen
		execute "normal 3\<c-w>-"
	elseif ('C-J' == a:dir && above == 0 && below == 1)
		" there are no windows below this on the screen but we are on the top
		execute "normal 3\<c-w>+"
	elseif ('C-K' == a:dir && above == 0 && below == 1)
		" there are no windows above this on the screen and we are on the top
		execute "normal 3\<c-w>-"
	elseif ('C-K' == a:dir && above == 1 && below == 0)
		" there are windows above this on the screen, and we are on the bottom
		execute "normal 3\<c-w>+"

	elseif ('C-J' == a:dir && above == 1 && below == 1)
		" this is a middle window and we are trying to drop it down
		execute "normal \<c-w>j3\<c-w>-\<c-w>p"
	elseif ('C-K' == a:dir && above == 1 && below == 1)
		" this is a middle window and we are trying to raise it up
		execute "normal \<c-w>k3\<c-w>-\<c-w>p"

	else
		echo "oops. check your ~/.vimrc"
		return
	endif
endfunction

" mappings for changing window size
nnoremap <silent> <C-J> :call Resize('C-J')<CR>
nnoremap <silent> <C-K> :call Resize('C-K')<CR>

" I want to jump to the exact position in the line
nnoremap '' ``

" I want to jump to the exact position in the line for marks
nnoremap ' `
nnoremap ` '


" run glg from within vim
function! Glg(...)
	execute "silent !git log --decorate --graph --color " . join(a:000) . " | less -R"
	redraw!
endfunction
command! -nargs=* Glg call Glg(<f-args>)
cabbrev glg Glg

" run git diff from within vim
function! Gdf(...)
	execute "silent !git diff --color " . join(a:000) . " | less -R"
	redraw!
endfunction
command! -nargs=* Gdf call Gdf(<f-args>)
cabbrev gdf Gdf

" run git push from within vim
function! Gpsh(...)
	execute "!git push " . join(a:000)
	redraw!
endfunction
command! -nargs=* Gpsh call Gpsh(<f-args>)
cabbrev gpsh Gpsh


" Open a bunch of tabs at once.  Also interpret globbing characters.
function! Tabopen_all_files(...)
	let i = 1
	let firstnewtab = 0

	" loop over arguments passed to this function, both file names, new tab
	" names, and filename globs
	while i <= a:0
		let filelist = split(glob(a:{i}), "\n")

		if len(filelist) == 0
			" if there are no files in the glob, then we just pass it to
			" tabedit
			execute "tabedit " . a:{i}
			if i == 1
				let firstnewtab = tabpagenr()
			endif
		else
			" loop over files in the glob, opening each one
			let j = 0
			while j < len(filelist)
				execute "tabedit " . filelist[j]
				" if this is the first new tab that we're opening,
				" we have to save the tab number so we can come back here
				" after we're done opening all the other tabs
				if i == 1 && j == 0
					let firstnewtab = tabpagenr()
				endif
				let j = j + 1
			endwhile
		endif

		let i = i + 1
	endwhile

	" if we opened any tabs, then we need to go back to
	" the first one we opened
	if firstnewtab
		execute "normal " . firstnewtab . "gt"
	endif
endfunction

" create a command ":Tabopen" that will call our tab-opening function
" and create an abbreviation for it with the name "tabo".  So, to use this
" just type ":tabo " and it will get replaced with ":Tabopen ".
command! -nargs=+ -complete=file Tabopen call Tabopen_all_files(<f-args>)
cabbrev tabo Tabopen


" Convert all arguments to function from relative references to a file
" based on the file currently being edited, so absolute references based
" on current working directory.
"
" For instance, if we are in /some/path/, and we are editing
" /some/path/src/nice.c, then if we call this with :tabopen join.c,
" the :tabopen function will get the argument src/join.c.
function! RelativeFunc(function, ...)
	let file_basename = expand("%:p:h")
	let relativefiles = copy(a:000)

	let i = 0
	while i < len(relativefiles)
		"let relativefiles[i] = file_basename . "/" . relativefiles[i]
		let relativefiles[i] = substitute(file_basename . "/" . relativefiles[i], getcwd() . "/", "", "")
		let relativefiles[i] = simplify(relativefiles[i])
		let i = i + 1
	endwhile

	call call(a:function, relativefiles)
endfunction

" A complete function for completing file names relative to the current
" file being edited.
"
" For instance, if we are in /some/path/, and we are editing
" /some/path/src/nice.c, if we try to complete a path using this func,
" we will intially get a list of files in /some/path/src/, NOT /some/path/.
function! RelativeFilesComplete(ArgLead, CmdLine, CursorPos)
	let file_basename = expand("%:p:h")
	let path = file_basename . "/" . a:ArgLead

	if isdirectory(path) && path[len(path) - 1] != "/"
		let path = path . "/"
	endif

	let relativefiles = split(glob(path . "*"), "\n")

	let index = 0
	while index < len(relativefiles)
		if isdirectory(relativefiles[index])
			let relativefiles[index] .= "/"
		endif
		let relativefiles[index] = substitute(relativefiles[index], file_basename . "/" , "", "")
		let index += 1
	endwhile

	return relativefiles
endfunction


command! -nargs=+ -complete=customlist,RelativeFilesComplete
			\ RelativeTabopen call RelativeFunc(function('Tabopen_all_files'), <f-args>)
cabbrev rt RelativeTabopen

" Execute the line under the cursor.
"function! ExecuteLine()
"	let thisline = getline('.')
"	execute '!' . thisline
"endfunction
"nnoremap <silent> <C-R> :call ExecuteLine()<CR>

" use command VGrep to list files in a vertical split. The '!' after grep
" makes the command not jump to the first occurance that was found.
command! -nargs=+ Vgrep execute 'silent grep! <args>' | vert copen 30
command! -nargs=+ Vlgrep execute 'silent lgrep! <args>' | vert copen 30
" use command Grep to list files in a new tab
command! -nargs=+ Grep execute 'silent grep! <args>' | tab copen
command! -nargs=+ LGrep execute 'silent lgrep! <args>' | tab copen
map <Leader>f :execute("Grep -r ".expand("<cword>")." .")<CR>

" Create command for curl'ing a file into the current buffer
command! -nargs=+ Curl execute 'read !curl <args> 2>/dev/null'
cabbrev curl Curl

" Autocommand to change what <CR> does on quickfix buffer.
" (It changes <CR> to open the first result in a new tab).
autocmd BufWinEnter * if &buflisted && &filetype == "qf" | noremap <buffer> <CR> <CR><C-W>T| endif

" Autocommand
" I don't think I need this anymore because I mapped :q to q.
"autocmd BufWinEnter * if &buflisted && &filetype == "qf" | noremap <buffer> q :q<CR>| endif

" source ~/.vim/plugin/cscope_maps.vim
" source ~/.vim/syntax/javascript.vim

" show when autocmds are called
"set verbose=9


""""""""" This uses the execute command to create an autocmd
""""""""" that sets the fold_method if the syntax matches.
""""""""" You have to use execute so that the variables get
""""""""" evaluated now instead of when the autocmd executes.

function! Add_auto_foldmethod(syntax_of_file, fold_method)
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"set foldmethod=" . a:fold_method . "\" | "
		\ " endif "
endfunction

" TODO: I can probably change all of these to the au FileType command being
" used at the bottom for xml.
call Add_auto_foldmethod('c', 'syntax')
call Add_auto_foldmethod('cpp', 'syntax')
"call Add_auto_foldmethod('asm', 'indent')
call Add_auto_foldmethod('java', 'syntax')
call Add_auto_foldmethod('python', 'indent')
call Add_auto_foldmethod('css', 'indent')
call Add_auto_foldmethod('sas', 'syntax')
"call Add_auto_foldmethod('xml', 'syntax')
call Add_auto_foldmethod('xsd', 'syntax')
call Add_auto_foldmethod('ant', 'syntax')
call Add_auto_foldmethod('javascript', 'indent')
call Add_auto_foldmethod('php', 'syntax')
call Add_auto_foldmethod('objc', 'syntax')
call Add_auto_foldmethod('haskell', 'syntax')
call Add_auto_foldmethod('puppet', 'indent')
call Add_auto_foldmethod('scala', 'indent')
au FileType xml set foldmethod=syntax

" Kind of like above, add a method specifying whether or not we
" want to highlight spaces at the end of a line
function! Add_eol_whitespace_highlighting(syntax_of_file)
	" autocmd InsertEnter/Leave doesn't seem to work just by giving the group
	" (like "c"), so we have to do this horrible, horrible thing.  In order to
	" understand this, first run "autocmd Syntax", and then look at "autocmd
	" InsertEnter" or "autocmd InsertLeave".  It should make a little more
	" sense.
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"autocmd InsertEnter <buffer> "
		\ " syn clear EOLWS | syn match EOLWS excludenl /\\\\s\\\\+\\\\%#\\\\@!$/ containedin=ALL\" | "
		\ " endif "
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"autocmd InsertLeave <buffer> "
		\ " syn clear EOLWS | syn match EOLWS excludenl /\\\\s\\\\+$/ containedin=ALL\" | "
		\ " endif "
	" create the highlight group we are using
	execute "autocmd Syntax " . a:syntax_of_file . 
		\ " highlight EOLWS ctermbg=white guibg=white"
	" now just run the command to actually highlight spaces at the end of lines so
	" we see them as soon as we open the file
	execute "autocmd Syntax " . a:syntax_of_file . 
		\ " syn clear EOLWS | syn match EOLWS excludenl /\\s\\+$/ containedin=ALL"
endfunction

call Add_eol_whitespace_highlighting("bash")
call Add_eol_whitespace_highlighting("c")
call Add_eol_whitespace_highlighting("cpp")
call Add_eol_whitespace_highlighting("haskell")
call Add_eol_whitespace_highlighting("html")
call Add_eol_whitespace_highlighting("java")
call Add_eol_whitespace_highlighting("php")
call Add_eol_whitespace_highlighting("puppet")
call Add_eol_whitespace_highlighting("python")
call Add_eol_whitespace_highlighting("ruby")
call Add_eol_whitespace_highlighting("scala")
call Add_eol_whitespace_highlighting("sh")
call Add_eol_whitespace_highlighting("vim")

" Make sure I can get spell checking when the file I am editing does not have
" a syntax associated with it.

" Python needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.py set expandtab
" maybe this could also be done with
autocmd FileType python set expandtab
" set autocomplete for python from the neocomplete plugin
"autocmd FileType python setlocal omnifunc=pythoncomplete#Complete

" Haskell also needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.hs set expandtab
autocmd BufRead,BufNewFile *.lhs set expandtab
" maybe this could also be done with
autocmd FileType haskell set expandtab

" Cabal files also needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.cabal set expandtab
autocmd FileType cabal set expandtab
autocmd BufRead,BufNewFile *.cabal setlocal filetype=cabal

" SConscript and SConstruct files are python files
autocmd BufRead,BufNewFile SConstruct set ft=python
autocmd BufRead,BufNewFile SConscript set ft=python

" special settings for sas files
autocmd FileType sas set tabstop=3			" 3-space tab indent width
autocmd FileType sas set shiftwidth=3		" allows you to use < and > to indent/unindent blocks
autocmd FileType sas set softtabstop=3		" see multiple space characters as a tab

" settings for c#
autocmd FileType cs set omnifunc=syntaxcomplete#Complete
autocmd FileType cs set foldmethod=marker
autocmd FileType cs set foldmarker={,}
autocmd FileType cs set foldtext=substitute(getline(v:foldstart),'{.*','{...}',)
autocmd FileType cs set foldlevelstart=2

" settings for ruby
autocmd FileType ruby setlocal tabstop=2
autocmd FileType ruby setlocal shiftwidth=2
autocmd FileType ruby setlocal softtabstop=2
autocmd FileType ruby setlocal expandtab
autocmd FileType ruby setlocal foldmethod=syntax

" settings for puppet
autocmd FileType puppet setlocal tabstop=2
autocmd FileType puppet setlocal shiftwidth=2
autocmd FileType puppet setlocal softtabstop=2
autocmd FileType puppet setlocal expandtab
autocmd FileType puppet setlocal foldmethod=indent

" settings for scala
autocmd FileType scala setlocal tabstop=2
autocmd FileType scala setlocal shiftwidth=2
autocmd FileType scala setlocal softtabstop=2
autocmd FileType scala setlocal expandtab
autocmd FileType scala setlocal foldmethod=indent

" settings for html
autocmd FileType html setlocal tabstop=2
autocmd FileType html setlocal shiftwidth=2
autocmd FileType html setlocal softtabstop=2
"autocmd FileType html setlocal expandtab
autocmd FileType html setlocal foldmethod=indent

" settings for markdown
autocmd BufNewFile,BufRead *.md set filetype=markdown

" Make vim jump to the last position that you were editing in the file.
" When we reload, tell vim to restore the cursor to the saved position.
" This long, ugly thing is needed because funny things happen when you
" use folding.
augroup JumpCursorOnEdit
 au!
 autocmd BufReadPost *
 \ if expand("<afile>:p:h") !=? $TEMP |
 \ if line("'\"") > 1 && line("'\"") <= line("$") |
 \ let JumpCursorOnEdit_foo = line("'\"") |
 \ let b:doopenfold = 1 |
 \ if (foldlevel(JumpCursorOnEdit_foo) > foldlevel(JumpCursorOnEdit_foo - 1)) |
 \ let JumpCursorOnEdit_foo = JumpCursorOnEdit_foo - 1 |
 \ let b:doopenfold = 2 |
 \ endif |
 \ exe JumpCursorOnEdit_foo |
 \ endif |
 \ endif
 " Need to postpone using "zv" until after reading the modelines.
 autocmd BufWinEnter *
 \ if exists("b:doopenfold") |
 \ exe "normal zv" |
 \ if(b:doopenfold > 1) |
 \ exe "+".1 |
 \ endif |
 \ unlet b:doopenfold |
 \ endif
augroup END


" turn these on if you want to use vim over a slow link
"set lazyredraw
"set nottyfast

" load a local .vimrc from "~/.vimrc-local" if it exists
let vimrc_dir = fnamemodify(expand($MYVIMRC), ":h")
let local_vimrc = vimrc_dir . "/.vimrc-local"
if filereadable(local_vimrc)
	execute "source " . local_vimrc
endif
