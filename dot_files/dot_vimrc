
" If there is a global vimrc, first read it.  This is used on Debian-based
" distros that have a global vimrc. The filepath for addons is specified in
" this global file.  Addons are then enabled and disabled with the
" vim-addon-manager command.  This global file resets some of my settings
" below, so this needs to be done before anything else is done.
if filereadable("/etc/vim/vimrc") " debian
	source /etc/vim/vimrc
endif
if filereadable("/etc/vimrc") " arch linux
	" source /etc/vimrc
endif

set nocompatible		" Explicitly turn off compatibility mode
filetype off

" This has to come first because it resets all highlighting.
set background=dark
colorscheme darkblue
"colorscheme default
"colorscheme delek
"colorscheme desert
"colorscheme torte

" Set my leader key to be space instead of \, and
" set my local leader key to be return.
" This needs to be set as soon as possible because
" things mapped with <Leader> are mapped with the
" current leader and don't get changed to be a new
" leader when you set a new leader. So we need to
" set this as soon as possible so that the leader
" gets mapped correctly when we are setting mappings
" that use the leader.
let mapleader = " "
let maplocalleader = "\r"

" load vundles if we have any
if isdirectory(expand("~/.vim/bundle/vundle/.git"))
	set runtimepath+=~/.vim/bundle/vundle/
	call vundle#rc()

	" let Vundle manage Vundle
	" required!
	Bundle 'gmarik/vundle'
	" Brief help
	" :BundleList          - list configured bundles
	" :BundleInstall(!)    - install (update) bundles
	" :BundleSearch(!) foo - search (or refresh cache first) for foo
	" :BundleClean(!)      - confirm (or auto-approve) removal of unused bundles
	"
	" see :h vundle for more details or wiki for FAQ
	" NOTE: comments after Bundle commands are not allowed.


	" These are the types of repos you add with Vundle:
	" (1) original repos on GitHub
	"Bundle 'tpope/vim-rails.git'
	" (2) vim-scripts repos
	"Bundle 'FuzzyFinder'
	" (3) non-GitHub repos
	"Bundle 'git://git.wincent.com/command-t.git'
	" (4) Git repos on your local machine (i.e. when working on your own plugin)
	"Bundle 'file:///Users/gmarik/path/to/plugin'


	" Here are some more good haskell-related plugins
	" http://blog.mno2.org/blog/2011/11/17/vim-plugins-for-haskell-programmers/
	" http://comments.gmane.org/gmane.comp.lang.haskell.cafe/108152?set_cite=hide
	" http://haskelllive.com/environment.html


	" :help syntastic to get more help
	" To toggle between active/passive type checking we can enable the following key bindings
	"map <silent> <Leader>e :Errors<CR>
	Bundle 'scrooloose/syntastic'
	" map <Leader>s :SyntasticToggleMode<CR>
	" Always populate the location list even if :Errors is not run.
	" (This is disabled by default to reduce conflicts with other plugins.)
	" With this enabled, you can jump to different errors
	let g:syntastic_always_populate_loc_list = 1
	" don't use the :sign interface to mark errors
	"let g:syntastic_enable_signs = 0
	" enable debugging
	"let g:syntastic_debug = 1
	"let g:syntastic_debug_file = "~/syntastic.log"
	let g:syntastic_ruby_checkers = ['mri', 'rubocop']
	" Ideally I would include 'flow' in this list, but it runs as `flow check`
	" instead of just `flow`, so it takes too long to run.
	let g:syntastic_javascript_checkers = ['jshint', 'jslint', 'eslint']
	" Add merlin to the list of ocaml checkers.
	let g:syntastic_ocaml_checkers = ['merlin']


	if version >= 701
		Bundle 'Shougo/vimproc'
		if isdirectory(expand("~/.vim/bundle/vimproc/.git")) &&
				\ !(filereadable(expand("~/.vim/bundle/vimproc/lib/vimproc_unix.so")) ||
				\   filereadable(expand("~/.vim/bundle/vimproc/lib/vimproc_linux64.so")) ||
				\   filereadable(expand("~/.vim/bundle/vimproc/lib/vimproc_linux32.so")))
			echo "You must run `(cd \"$HOME/.vim/bundle/vimproc/\" && make)` in order to install vimproc (for ghc-mod). You also might need t o update all vim bundles."
		endif


		" Must `cabal install ghc-mod` to be able to use this.
		" :GhcModType		- Show the type of an expression (can be used multiple
		"					  times to show bigger and bigger expressions)
		" :GhcModTypeClear  - Clear subexpression's highlight
		" :GhcModCheck      - Show compiler error/warnings in quickfix window
		" :GhcModLint       - Show suggestions by ghc-mod lint
		" :GhcModInfo       - Show the type of an expression
		" :GhcModTypeInsert - Insert the type of a function
		"
		" Only load this plugin if ghc-mod exists on the PATH.
		" (This plugin throws up a really annoying warning if
		" it is loaded and ghc-mod doesn't exist.)
		if executable('ghc-mod')
			Bundle 'eagletmt/ghcmod-vim'
			let g:ghcmod_type_highlight='ghcmodType'
			" TODO: Only use these when in haskell mode...
			map <Leader>gt :GhcModType<CR>
			map <Leader>gc :GhcModTypeClear<CR>
			map <Leader>gi :GhcModTypeInsert<CR>
			map <Leader>gn :GhcModInfo<CR>
		endif
	endif


	" Use neocomplete (works with necoghc)
	if version >= 704 && has("lua")
		" This turns on autocoompletion all the time.  It's really annoying.
		" let g:neocomplete#enable_at_startup=1
		Bundle 'Shougo/neocomplete'
	endif


	" Must `cabal install ghc-mod` to be able to use this.
	" Use omnicompletion for haskell.
	" See :help compl-omni for details on omni-completion.
	" Enable with :setlocal omnifunc=necoghc#omnifunc (set below...)
	" Can be used with Ctrl-X Ctrl-O
	let g:haskellmode_completion_ghc = 1
	Bundle 'eagletmt/neco-ghc'
	autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc


	" Must run `cabal install hoogle && hoogle data` before using.
	" Look up things through hoogle.
	" See :help hoogle for help.
	" :Hoogle         - run hoogle on the word under the cursor
	Bundle 'Twinside/vim-hoogle'


	" Must `cabal install hdevtools` to be able to use this.
	" This is basically the same as ghc-mod
	" :HdevtoolsInfo	- get info about a type
	" :HdevtoolsType	- get short type information
	"Bundle 'bitc/vim-hdevtools'


	" You can use keys like _i to automatically import stuff that
	" has not yet been imported.
	" But before you use this functionality, you must run :ExportDocIndex
	" Bundle 'lukerandall/haskellmode-vim'
	let g:haddock_browser="/usr/bin/firefox"
	let g:haddock_indexfiledir=$HOME . "/.vim/"


	" must `cabal install hlint` to be able to use hlint stuff.
	" This does some cool things with syntax highlighting for you.
	" It also does some really nice folding for us.
	" :HLint	-- run file through hlint
	" However, the haskell-vim plugin is better.
	" Bundle 'dag/vim2hs'
	" disable all conceals, including the simple ones like
	" lambda and composition
	" let g:haskell_conceal = 0
	" disable concealing of "enumerations": commatized lists like
	" deriving clauses and LANGUAGE pragmas,
	" otherwise collapsed into a single ellipsis
	" let g:haskell_conceal_enumerations = 0
	" Also disable conceal for jmacro.
	" let g:jmacro_conceal = 0


	" Haskell syntax highlighting.
	Bundle 'neovimhaskell/haskell-vim'
	"
	" Commands
	" :HaskellAddModuleComment  " Adds an empty module comment to the top of
	"                           " the file.
	" :CabalAddExecutable       " Adds an executable section to a cabal file.
	" :CabalAddLibrary          " Adds a library section to a cabal file.
	" :CabalAddFlag             " Adds a flag section to a cabal file.
	"
	" Haskell syntax highlighting config options:
	let g:haskell_enable_quantification = 1 " enable highlighting of forall
	"let g:haskell_enable_recursivedo = 1 " enable highlighting of mdo and rec
	"let g:haskell_enable_arrowsyntax = 1 " enable highlighting of proc
	"let g:haskell_enable_pattern_synonyms = 1 " enable highlighting of pattern
	"let g:haskell_enable_typeroles = 1 " enable highlighting of type roles
	"let g:haskell_enable_static_pointers = 1 " enable highlighting of static
	"
	" Indentation options:
	let g:haskell_indent_if = 2 " indentation of 'then' and 'else' in if statements.
	let g:haskell_indent_case = 2 " indentation of cases in case statement.
	let g:haskell_indent_let = 4 " indentation of additional lines in let statement.
	let g:haskell_indent_where = 2 " indentation of clauses in where statement.
	let g:haskell_indent_do = 2 " indentation of things in do statement.
	let g:haskell_indent_in = 0 " indentation of 'in' statement.
	let g:cabal_indent_section = 2  " indentation of sections in cabal file


	" EasyMotion.
	Bundle 'Lokaltog/vim-easymotion'


	" This uses :sign to show changed areas of code a la `git diff`.
	" Haven't really looked into this one yet either...
	"Bundle 'mhinz/vim-signify'


	" Nerdtree.  Need to enable this and make some mappings...
	Bundle 'scrooloose/nerdtree'
	nnoremap <F3> :NERDTreeToggle<CR>


	" Use multiple cursors just like Sublime text.  I almost feel
	" like this isn't needed because macros are so convenient...
	"Bundle 'terryma/vim-multiple-cursors'


	" Get more commands for doing things to surrounding text.
	Bundle 'tpope/vim-surround'


	" Get the ability to repeat these surround commands.
	Bundle 'tpope/vim-repeat'


	" This allows to write really short html.
	" You can convert the sparkup syntax to html with
	" Ctrl-E in insert mode, and then move to the next
	" empty element with Ctrl-N in insert mode.
	" Some examples of syntax are below:
	" https://github.com/rstacruz/sparkup
	" Other examples of syntax:
	" http://code.google.com/p/zen-coding/
	Bundle 'rstacruz/sparkup', {'rtp': 'vim/'}


	" nicer statusline
	" This seems like it would be nice, but I would have to configure it
	" not to look ugly.  Also, it doesn't seem like it would be too helpful
	" without the fugitive git plugin.
	"Bundle 'bling/vim-airline'


	" Shows git-diff stuff in the sign column and allows you to stage/revert
	" hunks.
	" :GitGutterDisable	             -- disable git gutter
	" :GitGutterLineHighlightsToggle -- toggle whether lines are highlighted
	" ]c and [c                      -- jump to next hunk
	" <Leader>hs                     -- stage the hunk
	" <Leader>hr                     -- revert the hunk
	" <Leader>hp                     -- preview the hunk?
	" These two are needed if gitgutter becomes slow.
	" let g:gitgutter_realtime = 0   -- Make it so that the gutter is not updated in realtime.
	" let g:gitgutter_eager = 0      -- Make it so that the gutter is not updated when switching tabs.
	Bundle 'airblade/vim-gitgutter'
	" Git gutter needs to use raw grep because I have colors turned on in my grep.
	let g:gitgutter_escape_grep = 1
	" By default, gitgutter make the signcolumn highlighting match the line
	" number highlighting.  This tells it not to do that.
	let g:gitgutter_override_sign_column_highlight = 0


	" Does various git commands.
	Bundle 'tpope/vim-fugitive'


	if version >= 701
		" Vim plugin for browsing tags of source code.  It opens up a sidebar that
		" displays ctags-generated gtags of the current file.
		Bundle 'majutsushi/tagbar'
		" F2 for turning on and off tag list
		nnoremap <F2> :TagbarToggle<CR>
		let g:tagbar_type_scala = {
			\ 'ctagstype' : 'Scala',
			\ 'kinds'     : [
				\ 'p:packages:1',
				\ 'V:values',
				\ 'v:variables',
				\ 'T:types',
				\ 't:traits',
				\ 'o:objects',
				\ 'a:aclasses',
				\ 'c:classes',
				\ 'r:cclasses',
				\ 'm:methods'
			\ ]
		\ }
	endif


	" Syntax files for puppet.
	Bundle 'puppetlabs/puppet-syntax-vim'


	" Scala syntax
	Bundle 'derekwyatt/vim-scala'


	" Rainbow parentheses
	" This doesn't play well with haskell files, so we need to disable it :-(
	" Bundle 'eapache/rainbow_parentheses.vim'
	" let g:rbpt_colorpairs = [
	"     \ ['darkred',     'DarkOrchid3'],
	"     \ ['darkgray',    'DarkOrchid3'],
	"     \ ['darkmagenta', 'DarkOrchid3'],
	"     \ ['darkgreen',   'RoyalBlue3'],
	"     \ ['red',         'firebrick3'],
	"     \ ['brown',       'RoyalBlue3'],
	"     \ ['darkmagenta', 'DarkOrchid3'],
	"     \ ['gray',        'RoyalBlue3'],
	"     \ ['darkcyan',    'SeaGreen3'],
	"     \ ['darkblue',    'SeaGreen3'],
	"     \ ['darkred',     'SeaGreen3'],
	"     \ ['darkgreen',   'firebrick3'],
	"     \ ['darkcyan',    'RoyalBlue3'],
	"     \ ['blue',        'firebrick3'],
	"     \ ['brown',       'firebrick3'],
	"     \ ['darkmagenta', 'DarkOrchid3'],
	"     \ ['darkgreen',   'RoyalBlue3'],
	"     \ ['red',         'firebrick3'],
	"     \ ]
	" " Turn off bold parenthesis
	" "let g:bold_parentheses = 0
	" autocmd VimEnter * if exists(":RainbowParenthesesActivate") |
	" 	\ exec ":RainbowParenthesesActivate" | endif
	" autocmd BufEnter * if exists(":RainbowParenthesesLoadRound") |
	" 	\ exec ":RainbowParenthesesLoadRound" | endif
	" autocmd BufEnter * if exists(":RainbowParenthesesLoadSquare") |
	" 	\ exec ":RainbowParenthesesLoadSquare" | endif
	" autocmd BufEnter * if exists(":RainbowParenthesesLoadBraces") |
	" 	\ exec ":RainbowParenthesesLoadBraces" | endif
	" "autocmd BufEnter * if exists(":RainbowParenthesesLoadChevrons") |
	" "	\ exec ":RainbowParenthesesLoadChevrons" | endif


	" This adds mappings like the following:
	" [a, ]a                :previous, :next
	" [b, ]b                :bprevious, :bnext
	" [l, ]l                :lprevious, :lnext   = Jump to next location in
	"                                              the location list.  This is
	"                                              helpful because syntastic
	"                                              adds errors to the location
	"                                              list.  We can jump to them
	"                                              fast with this.
	" [q, ]q                :cprevious, :cnext
	" [<Space>, ]<Space>    add a blank line above or below the cursor
	Bundle 'tpope/vim-unimpaired'


	" This adds the key command 'gcc' to comment out the
	" current line.  It also adds the command 'gc' in visual
	" mode to comment out a block.
	" In order to set the comment character for a specific filetype,
	" just use an autocommand like the following.
	" autocmd FileType apache set commentstring=#\ %s
	Bundle 'tpope/vim-commentary'
	autocmd FileType puppet set commentstring=#%s


	" This adds text selection/movement commands for working
	" with similarly indented blocks of code.
	" It depends on the following plugin:
	Bundle 'kana/vim-textobj-user'
	" Here is the plugin itself:
	"Bundle 'kana/vim-textobj-indent'
	" This adds text objects for Haskell top-level definitions (ih).
	" The current Haskell function can be formatted with the following key
	" combination:
	" gqih
	" (Actually, the (ap) text object seems to work for Haskell, so I might
	" not really need this.)
	Bundle 'gilligan/vim-textobj-haskell'
	" autocommand to create mapping to format the entire haskell file
	autocmd FileType haskell nnoremap <leader>hh mngggqG`n
	" autocommand to create mapping to format the current haskell text object
	autocmd FileType haskell nnoremap <leader>hf mngqap`n


	" Clever-f.
	" This makes the 'f' key be able to be repeated in order to jump
	" to the next match.  'F' is used to jump to previous matches.
	" This makes the ';' and ',' key free to be able to be used for other
	" things.
	"Bundle 'rhysd/clever-f.vim'


	" Haskell syntax for shakespearean templates.
	" Hamlet, Lucius, Julius.
	Bundle 'pbrisbin/vim-syntax-shakespeare'
	" Don't highlight trailing space on the end of the line.
	" I do this myself.
	let g:hamlet_highlight_trailing_space = 0

	if version >= 703
		" A shell for vim.
		" :VimShell                           Open the shell.  It can be used like
		"                                     bash.
		" :VimShellInteractive idris          Run another program in the shell.
		"                                     For example, we can run ghci.
		Bundle 'Shougo/vimshell.vim'
	endif

	" Idris mode for vim.
	Bundle 'idris-hackers/idris-vim'

	" Ledger syntax for vim
	let g:ledger_bin = 'hledger'
	Bundle 'ledger/vim-ledger'
	autocmd BufEnter .hledger.journal setlocal filetype=ledger

	" JSON syntax highlighting
	Bundle 'elzr/vim-json'
	" Don't let the plugin conceal double quotes
	let g:vim_json_syntax_conceal = 0

	" Elm mode.
	"   Available Commands:
	"     :ElmMakeCurrentFile    compiles the current file.
	"     :ElmMakeMain           compiles an assumed Main.elm file.
	"     :ElmPrintTypes         displays the types of the current
	"                            file in a new split window.
	"     :ElmEvalLine           evaluates the current line and puts
	"                            the result as a comment in a new line below it.
	"     :ElmEvalSelection      evaluates a visual mode selection.
	"   Suggested Mappings:
	"     :nnoremap <leader>el :ElmEvalLine<CR>
	"     :vnoremap <leader>es :<C-u>ElmEvalSelection<CR>
	"     nnoremap <leader>ep :ElmPrintTypes<CR>
	"     nnoremap <leader>em :ElmMakeCurrentFile<CR>
	"   Suggested Autocommands:
	"     Compile Main.elm when writing any elm file.  The autocommand can be
	"     cleared with `:au! BufWritePost *.elm`.
	"       :au BufWritePost *.elm ElmMakeFile("Main.elm")
	Bundle 'lambdatoast/elm.vim'

	" Align code.
	"   Available Commands:
	"     :Align        basic alignment command
	"     :AlignCtrl    provide options for next call to :Align
	"   Mappings:
	"     \t=           align assignments (don't count logic, like == or !=)
	"     \t,           align on commas
	"     \t|           align on vertical bars (|)
	"     \tsp          align on whitespace
	"   Examples:
	"     :5,10Align =
	"         Align on '=' signs
	"     :'<,'>Align = + - \* /
	"         Align on any of the five separator characters shown.
	"         Note that visual block mode was used to fire off Align.
	"     :AlignCtrl =lp1P1I
	"         which means:
	"           =   all separators are equivalent
	"           l   fields will be left-justified
	"           p1  pad one space before each separator
	"           P1  pad one space after each separator
	"           I   preserve and apply the first line's leading white space
	"               to all Align'd lines
	"     :help align
	"         open help file
	Bundle 'vim-scripts/Align'

	" Ocaml syntax.
	" Bundle 'rgrinberg/vim-ocaml'

	" Purescript syntax.
	Bundle 'raichoo/purescript-vim'

	" hsimport
	" Bundle 'dan-t/vim-hsimport'

	" align code
	Bundle 'godlygeek/tabular'
	" With the following mappings, we are able to align stuff in visual mode.
	" For instance, if we had the following code:
	"        What -> pure 1
	"        Who -> pure 2
	"        Whomever -> pure 3
	" And you highlighted it and hit 'a-', it would make it look like this:
	"        What     -> pure 1
	"        Who      -> pure 2
	"        Whomever -> pure 3
	vmap a= :Tabularize /=<CR>
	vmap a; :Tabularize /::<CR>
	vmap a- :Tabularize /-><CR>
	vmap ac :Tabularize /--<CR>

	" Markdown support.  Required to be run after the "tabular" plugin.
	" The folding in this doesn't work correctly.
	"Bundle 'plasticboy/vim-markdown'

	" Folding for markdown.
	" This folding doesn't work correctly either.
	"Bundle 'nelstrom/vim-markdown-folding'

	" Haskell code formatting with hindent.
	" (This doesn't really have a formatter that I like.)
	"Bundle 'octol/vim-hindent'
	"let g:hindent_style = 'cramer'

	" Erlang plugin for syntax checking and omnicomplete.
	Bundle 'vim-erlang/vim-erlang-compiler'
	Bundle 'vim-erlang/vim-erlang-omnicomplete'

	" Snippets.
	" The snippet engine, and the repo of snippets.
	Plugin 'SirVer/ultisnips'
	Plugin 'honza/vim-snippets'
	" Trigger configuration.
	let g:UltiSnipsExpandTrigger="<c-g>"
	let g:UltiSnipsJumpForwardTrigger="<c-j>"
	let g:UltiSnipsJumpBackwardTrigger="<c-k>"
	" If you want :UltiSnipsEdit to split your window.
	" let g:UltiSnipsEditSplit="vertical"

	" Pug file highlighting
	Bundle 'digitaltoad/vim-pug'
endif


"""""""""""""""""""""""""""""""""""""""""""""
""""""""""""" General Settings """"""""""""""
"""""""""""""""""""""""""""""""""""""""""""""

" make sure that ~/.vim is first in the runtimepath.  Commands like zg will
" store files by default in the first entry in the runtime path.
" (In this case, it will store the default spell file in a file like
" spell/en.utf-8.spl in the first entry in runtimepath.)
let &runtimepath=("~/.vim/," . &runtimepath)

" I am moving syntax on down to here because putting it above was
" causing puppetlabs/puppet-syntax-vim to not pickup the ftdetect
" settings for puppet files.  But this causes all highlights that
" have been defined to be undefined, so all of my highlights have
" to go below.
syntax on
filetype plugin indent on

set fileencodings=utf-8
setglobal fileencoding=utf-8
set encoding=utf-8
set ttymouse=xterm2   " mouse scrolling in vim
set mouse=a
set foldenable
set tabstop=4         " 4-space tab indent width
set shiftwidth=4      " allows you to use < and > to indent/unindent blocks
set softtabstop=4     " see multiple space characters as a tab
set shiftround        " Indent to nearest tab stop
set autoindent        " carries over previous indent to the next line
set smarttab          " A tab infront of a line inserts spaces or tabs according to expandtab
set autoread          " when file detected changed outside of Vim, automatically read it again

if version <= 702
	set switchbuf=usetab,useopen
else
	set switchbuf=usetab,useopen,newtab
endif

" Tell vim to remember certain things when we exit
"  '100 : marks will be remembered for up to 100 previously edited files
"  "100 : will save up to 100 lines for each register
"  :20 : up to 20 lines of command-line history will be remembered
"  % : saves and restores the buffer list
"  n... : where to save the viminfo files
set viminfo='100,\"100,:20,%,n~/.viminfo

set wildmode=list:longest   " When autocompleting things, do it like the shell
set wildmenu                " Autocomplete things on the menu?
set scrolloff=3             " Scroll when the cursor is 3 lines from top or bottom
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set ruler                   " know how far you are in a file
set enc=utf-8
set fenc=utf-8
set backspace=indent,eol,start	" make sure backspace works correctly

set guifont=Bitstream\ Vera\ Sans\ Mono\ 14 "font names to be used in gui

" this combination works out well to only apply case to searches
" if there is an uppercase letter in your search string
set ignorecase
set smartcase

" this uses the tags file if it is found anywhere above this directory
" in a file called tags.  If it can't find it, it then looks for a file
" called build/tags in any directory above this one
set tags+=tags;$HOME,build/tags;$HOME

" always show a tabline
set showtabline=2

" set the maximum number of files you can open in tabs
if &tabpagemax < 50
	  set tabpagemax=50
endif

" Use an undo file to save undos through closing file
if version >= 703
	set undodir=~/.vim-undo,/var/tmp,/tmp
	set undofile
endif

" Show relative line numbers.
set number
set relativenumber

"""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""" Spelling """""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""

" Make sure my spell checking is done in English.  (This is the default).
set spelllang=en

" Vim searches for additional spell files in the "spell/" subdirectory of the
" directories in "runtimepath" (usually, "~/.vim/" is on the "runtimepath", so
" it will look in "~/.vim/spell/").  By default, it looks for files of the
" name "LL.EEE.add", where "LL" is the language name (by default "en") and
" where "EEE" is the encoding (by default "utf-8").

" Commands:
"
"   - :setlocal spell                                 Turn on spell checking for
"                                                     the current buffer.
"
"   - :set spellfile=~/.vim/myspellfile.utf-8.add     Change the spell file to
"                                                     a custom spellfile.  It
"                                                     must end in
"                                                     ".{encoding}.add".
"
"   - zg       Add word under cursor to spell file as "correct word"
"
"   - zw       Add word under cursor to spell file as "incorrect word"
"
"   - zug      Undo "zg"
"
"   - zuw      Undo "zw"
"
"   - ]s       Move to the next misspelled word after the cursor.
"
"   - [s       Move to the previous misspelled word before the cursor.
"


"""""""""""""""""""""""""""""""""""""""""""""
"""""""""""" Highlighting """""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""

" NOTE: Highlighting has to be set here.  It must come after ":syntax on",
" because ":syntax on" will reset all the highlighting.  So I can't put
" any highlighting stuff above in the Vundle settings.  It all must go below.

" Give us some additional colors for highlighting haskell code.
" This is for vim2hs.
highlight hsType ctermfg=green
highlight hsStructure ctermfg=darkMagenta
highlight hsExprKeyword ctermfg=3
highlight hsConditional ctermfg=3
"highlight hsDelimiter ctermfg=...
highlight hsOperator ctermfg=blue

" This lets ghcmod give us nice yellow background highlighting when
" looking at an expression's type. This is for the ghcmod plugin.
highlight ghcmodType ctermfg=0 ctermbg=yellow guifg=black guibg=yellow

" highlight tab line differently
highlight TabLine term=bold,reverse cterm=bold ctermfg=black ctermbg=white
highlight TabLineFill term=bold,reverse cterm=bold ctermfg=white ctermbg=white
highlight TabLineSel term=reverse ctermfg=white ctermbg=lightblue

" highlight the popup menu a little differently
highlight PmenuSel ctermbg=lightblue

" make sure the normal background is black
highlight Normal guibg=black

" Make sure Special items are not Red.  The scala syntax highlighting makes
" objects (strings that start with a captial letter) this "Special" value, and
" it makes them dark red.  It makes them look like comments.  This makes them
" a brighter red so they stand out from comments.
highlight Special ctermfg=red

" Set highlighting for sign column.  This looks like it is the default on
" Arch Linux and is set in the colorscheme file, but for some reason it is
" different on Debian.  Set it here so it is the same on both.
highlight SignColumn term=standout ctermfg=14 ctermbg=238


"""""""""""""""""""""""""""""""""""""""""""""
"""""" Settings for specific syntaxes """""""
"""""""""""""""""""""""""""""""""""""""""""""

" settings specifically for java from
" http://vimdoc.sourceforge.net/htmldoc/syntax.html
let java_highlight_java_lang_ids=1
let java_highlight_all=1
"let java_highlight_functions="style"
"let java_allow_cpp_keywords=1

" make sure xml files are folded
let g:xml_syntax_folding=1

" make sure javascript files are folded
"let g:javaScript_fold=1

" do php folding
let g:php_folding=2

" this is needed for running taglist in screen:
let Tlist_Inc_Winwidth = 0


"""""""""""""""""""""""""""""""""""""""""""""
"""""""""""""""""" Maps """""""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""

" use F5 for turning off and on hlsearch,
" in both input mode (imap?) and command mode (map?)
map <F5> :set hlsearch!<CR>
imap <F5> <ESC>:set hlsearch!<CR>a

" use F6 for turning on and off paste mode
map <F6> :set paste!<CR>
imap <F6> <ESC>:set paste!<CR>a
set pastetoggle=<F6>

" use F7 for turning on and off list mode
map <F7> :set list!<CR>
imap <F7> <ESC>:set list!<CR>a

" use F8 for turning on and off spell check mode for the current buffer
map <F8> :setlocal spell!<CR>
imap <F8> <ESC>:setlocal spell!<CR>a

" use <C-h> and <C-l> to go forward and backward in tabs
" nnoremap just makes a normal mode mapping
nnoremap <C-h> gT
nnoremap <C-l> gt


if v:version < 704
	map <silent> <C-u> :let b:new_tab_number = tabpagenr() \| exec ":tabm " . b:new_tab_number \| unlet b:new_tab_number<CR>
else
	map <silent> <C-u> :let b:new_tab_number = tabpagenr() + 1 \| exec ":tabm " . b:new_tab_number \| unlet b:new_tab_number<CR>
endif
map <silent> <C-y> :let b:new_tab_number = tabpagenr() - 2 \| if (b:new_tab_number < 0) \| let b:new_tab_number = 0 \| endif \| exec ":tabm " . b:new_tab_number \| unlet b:new_tab_number<CR>

" go to tab number (really only for gvim)
nnoremap <A-1> 1gt
nnoremap <A-2> 2gt
nnoremap <A-3> 3gt
nnoremap <A-4> 4gt
nnoremap <A-5> 5gt
nnoremap <A-6> 6gt
nnoremap <A-7> 7gt
nnoremap <A-8> 8gt
nnoremap <A-9> 9gt
nnoremap <A-0> 10gt

" use <C-Enter> to jump to the tag under the cursor in a new tab.
" Also check out "<C-w>T", it takes a split screen off to a new tab.
" THIS DOESN'T WORK FOR SOME REASON:
"nnoremap <C-{> <C-w><C-]><C-w>T
" this can also be something like this:
map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap sudow w !sudo tee > /dev/null %

" Q is used to mess with macros.  q is used to close tabs/windows.
" Q's original function is to go into EX-mode.  I almost never want
" to go to EX mode, so I made this mapping.
noremap Q q
map q :q<CR>

" use CTRL-s for saving
" this doesn't work...
"nmap <c-s> :w<CR>
"imap <c-s> <Esc>:w<CR>a

" in input mode, what about we try using jj as escape
inoremap jj <Esc>

" I want to jump to the exact position in the line
nnoremap '' ``

" I want to jump to the exact position in the line for marks
nnoremap ' `
nnoremap ` '

" Let zz do :w
nnoremap zz :w<CR>

vnoremap <C-F> <PageDown>


"""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""" Functions """""""""""""""""""
"""""""""""""""""""""""""""""""""""""""""""""

function! Resize(dir)
	" TODO: could also do something like this for horizontal split screen
	let above = 0
	let below = 0

	let this = winnr()

	if a:dir == 'C-J' || a:dir == 'C-K'
		execute "normal \<c-w>k"
		let up = winnr()
		if up != this
			execute "normal \<c-w>j"
			let above = 1
		endif

		execute "normal \<c-w>j"
		let down = winnr()
		if down != this
			execute "normal \<c-w>k"
			let below = 1
		endif

	"elseif '>' == a:dir || '<' == a:dir
	"	execute "normal \<c-w>h"
	"	let left = winnr()
	"	if left != this
	"		execute "normal \<c-w>l"
	"		let x = 'right'
	"	else
	"		let x = 'left'
	"	endif
	else
		echo "oops. check your ~/.vimrc here."
		return
	endif

	if ( ('C-J' == a:dir || 'C-K' == a:dir) && above == 0 && below == 0 )
		" this is the only window on the screen
		return

	elseif ('C-J' == a:dir && above == 1 && below == 0)
		" there are no windows below this on the screen
		execute "normal 3\<c-w>-"
	elseif ('C-J' == a:dir && above == 0 && below == 1)
		" there are no windows below this on the screen but we are on the top
		execute "normal 3\<c-w>+"
	elseif ('C-K' == a:dir && above == 0 && below == 1)
		" there are no windows above this on the screen and we are on the top
		execute "normal 3\<c-w>-"
	elseif ('C-K' == a:dir && above == 1 && below == 0)
		" there are windows above this on the screen, and we are on the bottom
		execute "normal 3\<c-w>+"

	elseif ('C-J' == a:dir && above == 1 && below == 1)
		" this is a middle window and we are trying to drop it down
		execute "normal \<c-w>j3\<c-w>-\<c-w>p"
	elseif ('C-K' == a:dir && above == 1 && below == 1)
		" this is a middle window and we are trying to raise it up
		execute "normal \<c-w>k3\<c-w>-\<c-w>p"

	else
		echo "oops. check your ~/.vimrc"
		return
	endif
endfunction

" mappings for changing window size
nnoremap <silent> <C-J> :call Resize('C-J')<CR>
nnoremap <silent> <C-K> :call Resize('C-K')<CR>

" run glg from within vim
function! Glg(...)
	execute "silent !git log --decorate --graph --color " . join(a:000) . " | less -R"
	redraw!
endfunction
command! -nargs=* Glg call Glg(<f-args>)
cabbrev glg Glg

" run git diff from within vim
function! Gdf(...)
	execute "silent !git diff --color " . join(a:000) . " | less -R"
	redraw!
endfunction
command! -nargs=* Gdf call Gdf(<f-args>)
cabbrev gdf Gdf

" run git push from within vim
function! Gpsh(...)
	execute "!git push " . join(a:000)
	redraw!
endfunction
command! -nargs=* Gpsh call Gpsh(<f-args>)
cabbrev gpsh Gpsh

" run git commit -a -m from within vim
function! Gcam(...)
	execute "!git commit -a -m \"" . join(a:000) . "\""
	redraw!
endfunction
command! -nargs=* Gcam call Gcam(<f-args>)
cabbrev gcam Gcam

" run git commit -a -m from within vim
function! Gcamp(...)
	execute "!git commit -a -m \"" . join(a:000) . "\" && git push"
	redraw!
endfunction
command! -nargs=* Gcamp call Gcamp(<f-args>)
cabbrev gcamp Gcamp


" Open a bunch of tabs at once.  Also interpret globbing characters.
function! Tabopen_all_files(...)
	let i = 1
	let firstnewtab = 0

	" loop over arguments passed to this function, both file names, new tab
	" names, and filename globs
	while i <= a:0
		let filelist = split(glob(a:{i}), "\n")

		if len(filelist) == 0
			" if there are no files in the glob, then we just pass it to
			" tabedit
			execute "tabedit " . a:{i}
			if i == 1
				let firstnewtab = tabpagenr()
			endif
		else
			" loop over files in the glob, opening each one
			let j = 0
			while j < len(filelist)
				execute "tabedit " . filelist[j]
				" if this is the first new tab that we're opening,
				" we have to save the tab number so we can come back here
				" after we're done opening all the other tabs
				if i == 1 && j == 0
					let firstnewtab = tabpagenr()
				endif
				let j = j + 1
			endwhile
		endif

		let i = i + 1
	endwhile

	" if we opened any tabs, then we need to go back to
	" the first one we opened
	if firstnewtab
		execute "normal " . firstnewtab . "gt"
	endif
endfunction

" create a command ":Tabopen" that will call our tab-opening function
" and create an abbreviation for it with the name "tabo".  So, to use this
" just type ":tabo " and it will get replaced with ":Tabopen ".
command! -nargs=+ -complete=file Tabopen call Tabopen_all_files(<f-args>)
cabbrev tabo Tabopen


" Convert all arguments to function from relative references to a file
" based on the file currently being edited, so absolute references based
" on current working directory.
"
" For instance, if we are in /some/path/, and we are editing
" /some/path/src/nice.c, then if we call this with :tabopen join.c,
" the :tabopen function will get the argument src/join.c.
function! RelativeFunc(function, ...)
	let file_basename = expand("%:p:h")
	let relativefiles = copy(a:000)

	let i = 0
	while i < len(relativefiles)
		"let relativefiles[i] = file_basename . "/" . relativefiles[i]
		let relativefiles[i] = substitute(file_basename . "/" . relativefiles[i], getcwd() . "/", "", "")
		let relativefiles[i] = simplify(relativefiles[i])
		let i = i + 1
	endwhile

	call call(a:function, relativefiles)
endfunction

" A complete function for completing file names relative to the current
" file being edited.
"
" For instance, if we are in /some/path/, and we are editing
" /some/path/src/nice.c, if we try to complete a path using this func,
" we will intially get a list of files in /some/path/src/, NOT /some/path/.
function! RelativeFilesComplete(ArgLead, CmdLine, CursorPos)
	let file_basename = expand("%:p:h")
	let path = file_basename . "/" . a:ArgLead

	if isdirectory(path) && path[len(path) - 1] != "/"
		let path = path . "/"
	endif

	let relativefiles = split(glob(path . "*"), "\n")

	let index = 0
	while index < len(relativefiles)
		if isdirectory(relativefiles[index])
			let relativefiles[index] .= "/"
		endif
		let relativefiles[index] = substitute(relativefiles[index], file_basename . "/" , "", "")
		let index += 1
	endwhile

	return relativefiles
endfunction


command! -nargs=+ -complete=customlist,RelativeFilesComplete
			\ RelativeTabopen call RelativeFunc(function('Tabopen_all_files'), <f-args>)
cabbrev rt RelativeTabopen

" This renames a file.  It is relative to the CWD.  It deletes the old file.
" It also saves the undo history.
" TODO: It would also be nice to make this a shared vim plugin, instead of
" hard-coding it here.
function! Rename(name)
	let l:name    = a:name
	let l:oldfile = expand('%:p')

    " If the l:name is the name of a directory, than append the basename of
    " l:oldfile to it and use it.
    if isdirectory(l:name)
        let l:name = l:name . fnamemodify(l:oldfile, ':p:t')
    endif

	if bufexists(fnamemodify(l:name, ':p'))
		echohl ErrorMsg
		echomsg 'A buffer with that name already exists (use ! to override).'
		echohl None
		return 0
	endif

	let l:status = 1

	let v:errmsg = ''
	silent! exe 'saveas' . ' ' . l:name

	if v:errmsg =~# '^$\|^E329'
		let l:lastbufnr = bufnr('$')

		if expand('%:p') !=# l:oldfile && filewritable(expand('%:p'))
			if fnamemodify(bufname(l:lastbufnr), ':p') ==# l:oldfile
				silent exe l:lastbufnr . 'bwipe!'
			else
				echohl ErrorMsg
				echomsg 'Could not wipe out the old buffer for some reason.'
				echohl None
				let l:status = 0
			endif

			if delete(l:oldfile) != 0
				echohl ErrorMsg
				echomsg 'Could not delete the old file: ' . l:oldfile
				echohl None
				let l:status = 0
			endif
		else
			echohl ErrorMsg
			echomsg 'Rename failed for some reason.'
			echohl None
			let l:status = 0
		endif
	else
		echoerr v:errmsg
		let l:status = 0
	endif

	return l:status
endfunction

command! -nargs=1 -complete=customlist,RelativeFilesComplete
			\ Rename call RelativeFunc(function('Rename'), <f-args>)
cabbrev rename Rename

" This copies a file.  It is relative to the CWD.  It's like :Rename but it
" doesn't delete the old file.
" TODO: It would also be nice to make this a shared vim plugin, instead of
" hard-coding it here.
function! Copy(name)
	let l:name    = a:name
	let l:oldfile = expand('%:p')

    " If the l:name is the name of a directory, than append the basename of
    " l:oldfile to it and use it.
    if isdirectory(l:name)
        let l:name = l:name . fnamemodify(l:oldfile, ':p:t')
    endif

	" I don't think I actually need this check...
	" if bufexists(fnamemodify(l:name, ':p'))
	" 	echohl ErrorMsg
	" 	echomsg 'A buffer with that name already exists (use ! to override).'
	" 	echohl None
	" 	return 0
	" endif

	let v:errmsg = ''

	let l:cpo_save = &cpoptions
	set cpoptions-=A

	silent! exe 'write ' . l:name

	let &cpoptions = l:cpo_save

	if v:errmsg != ''
		echohl ErrorMsg
		echomsg 'Copying file ' . l:oldfile . ' to ' . l:name . ' failed:'
		echoerr v:errmsg
		return 0
	endif

	silent! exe 'tabedit ' . l:name

	if v:errmsg != ''
		echohl ErrorMsg
		echomsg 'tabopen file ' . l:oldfile . ' failed:'
		echoerr v:errmsg
		return 0
	endif

	return 1
endfunction

command! -nargs=1 -complete=customlist,RelativeFilesComplete
			\ Copy call RelativeFunc(function('Copy'), <f-args>)
cabbrev cp Copy

" Make a new directory.  It is relative to the directory of the currently
" opened buffer.
" TODO: It would also be nice to make this a shared vim plugin, instead of
" hard-coding it here.
function! Mkdir(name)
	let l:name = a:name

    " If the l:name already exists, show an error message.
    if isdirectory(l:name) || filereadable(l:name)
		echohl ErrorMsg
		echomsg 'Tried to create directory "' . l:name . '", but it already exists.'
		return 0
    endif

	silent let l:output = system('mkdir -p ' . l:name)

	if v:shell_error != 0
		echohl ErrorMsg
		echomsg 'Tried to create directory "' . l:name . '", but failed with error code "' . v:shell_error . '" and output:'
		echoerr l:output
		return 0
	endif

	return 1
endfunction

command! -nargs=1 -complete=customlist,RelativeFilesComplete
			\ Mkdir call RelativeFunc(function('Mkdir'), <f-args>)
cabbrev mkdir Mkdir

" Execute the line under the cursor.
"function! ExecuteLine()
"	let thisline = getline('.')
"	execute '!' . thisline
"endfunction
"nnoremap <silent> <C-R> :call ExecuteLine()<CR>

" use command VGrep to list files in a vertical split. The '!' after grep
" makes the command not jump to the first occurance that was found.
command! -nargs=+ Vgrep execute 'silent grep! <args>' | vert copen 30
command! -nargs=+ Vlgrep execute 'silent lgrep! <args>' | vert copen 30
" use command Grep to list files in a new tab
command! -nargs=+ Grep execute 'silent grep! <args>' | tab copen
command! -nargs=+ LGrep execute 'silent lgrep! <args>' | tab copen
map <Leader>f :execute("Grep -I -r ".expand("<cword>")." .")<CR>

" Create command for curl'ing a file into the current buffer
command! -nargs=+ Curl execute 'read !curl <args> 2>/dev/null'
cabbrev curl Curl

" Autocommand to change what <CR> does on quickfix buffer.
" (It changes <CR> to open the first result in a new tab).
autocmd BufWinEnter * if &buflisted && &filetype == "qf" | noremap <buffer> <CR> <CR><C-W>T| endif

" Autocommand
" I don't think I need this anymore because I mapped :q to q.
"autocmd BufWinEnter * if &buflisted && &filetype == "qf" | noremap <buffer> q :q<CR>| endif

" source ~/.vim/plugin/cscope_maps.vim
" source ~/.vim/syntax/javascript.vim

" show when autocmds are called
"set verbose=9


" Make vim jump to the last position that you were editing in the file.
" When we reload, tell vim to restore the cursor to the saved position.
" This long, ugly thing is needed because funny things happen when you
" use folding.
" augroup JumpCursorOnEdit
"  au!
"  autocmd BufReadPost *
"  \ if expand("<afile>:p:h") !=? $TEMP |
"  \ if line("'\"") > 1 && line("'\"") <= line("$") |
"  \ let JumpCursorOnEdit_foo = line("'\"") |
"  \ let b:doopenfold = 1 |
"  \ if (foldlevel(JumpCursorOnEdit_foo) > foldlevel(JumpCursorOnEdit_foo - 1)) |
"  \ let JumpCursorOnEdit_foo = JumpCursorOnEdit_foo - 1 |
"  \ let b:doopenfold = 2 |
"  \ endif |
"  \ exe JumpCursorOnEdit_foo |
"  \ endif |
"  \ endif
"  " Need to postpone using "zv" until after reading the modelines.
"  autocmd BufWinEnter *
"  \ if exists("b:doopenfold") |
"  \ exe "normal zv" |
"  \ if(b:doopenfold > 1) |
"  \ exe "+".1 |
"  \ endif |
"  \ unlet b:doopenfold |
"  \ endif
" augroup END

" This is a newer function that apparently works better.
function! ResCur()
	if line("'\"") <= line("$")
		normal! g`"
		return 1
	endif
endfunction

if has("folding")
	function! UnfoldCur()
		if !&foldenable
			return
		endif
		let cl = line(".")
		if cl <= 1
			return
		endif
		let cf  = foldlevel(cl)
		let uf  = foldlevel(cl - 1)
		let min = (cf > uf ? uf : cf)
		if min
			execute "normal!" min . "zo"
			return 1
		endif
	endfunction
endif

augroup resCur
	autocmd!
	if has("folding")
		autocmd BufWinEnter * if ResCur() | call UnfoldCur() | endif
	else
		autocmd BufWinEnter * call ResCur()
	endif
augroup END


"""""""""""""""""""""""""""""""""""""""""""""
"""""""" Specific filetype settings """""""""
"""""""""""""""""""""""""""""""""""""""""""""

" This uses the execute command to create an autocmd
" that sets the fold_method if the syntax matches.
" You have to use execute so that the variables get
" evaluated now instead of when the autocmd executes.
function! Add_auto_foldmethod(syntax_of_file, fold_method)
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"set foldmethod=" . a:fold_method . "\" | "
		\ " endif "
endfunction

" TODO: I can probably change all of these to the au FileType command being
" used at the bottom for xml.
"call Add_auto_foldmethod('asm', 'indent')
call Add_auto_foldmethod('ant', 'syntax')
call Add_auto_foldmethod('c', 'syntax')
call Add_auto_foldmethod('cpp', 'syntax')
call Add_auto_foldmethod('css', 'indent')
call Add_auto_foldmethod('erlang', 'syntax')
call Add_auto_foldmethod('haskell', 'syntax')
call Add_auto_foldmethod('java', 'syntax')
call Add_auto_foldmethod('javascript', 'indent')
call Add_auto_foldmethod('json', 'syntax')
call Add_auto_foldmethod('objc', 'syntax')
call Add_auto_foldmethod('php', 'syntax')
call Add_auto_foldmethod('puppet', 'indent')
call Add_auto_foldmethod('python', 'indent')
call Add_auto_foldmethod('sas', 'syntax')
call Add_auto_foldmethod('scala', 'indent')
"call Add_auto_foldmethod('xml', 'syntax')
call Add_auto_foldmethod('xsd', 'syntax')
au FileType xml set foldmethod=syntax

" Kind of like above, add a method specifying whether or not we
" want to highlight spaces at the end of a line
function! Add_eol_whitespace_highlighting(syntax_of_file)
	" autocmd InsertEnter/Leave doesn't seem to work just by giving the group
	" (like "c"), so we have to do this horrible, horrible thing.  In order to
	" understand this, first run "autocmd Syntax", and then look at "autocmd
	" InsertEnter" or "autocmd InsertLeave".  It should make a little more
	" sense.
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"autocmd InsertEnter <buffer> "
		\ " syn clear EOLWS | syn match EOLWS excludenl /\\\\s\\\\+\\\\%#\\\\@!$/ containedin=ALL\" | "
		\ " endif "
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"autocmd InsertLeave <buffer> "
		\ " syn clear EOLWS | syn match EOLWS excludenl /\\\\s\\\\+$/ containedin=ALL\" | "
		\ " endif "
	" create the highlight group we are using
	execute "autocmd Syntax " . a:syntax_of_file . 
		\ " highlight EOLWS ctermbg=white guibg=white"
	" now just run the command to actually highlight spaces at the end of lines so
	" we see them as soon as we open the file
	execute "autocmd Syntax " . a:syntax_of_file . 
		\ " syn clear EOLWS | syn match EOLWS excludenl /\\s\\+$/ containedin=ALL"
endfunction

call Add_eol_whitespace_highlighting("bash")
call Add_eol_whitespace_highlighting("c")
call Add_eol_whitespace_highlighting("cpp")
call Add_eol_whitespace_highlighting("css")
call Add_eol_whitespace_highlighting("elm")
call Add_eol_whitespace_highlighting("erlang")
call Add_eol_whitespace_highlighting("hamlet")
call Add_eol_whitespace_highlighting("haskell")
call Add_eol_whitespace_highlighting("html")
call Add_eol_whitespace_highlighting("java")
call Add_eol_whitespace_highlighting("javascript")
call Add_eol_whitespace_highlighting("json")
call Add_eol_whitespace_highlighting("julius")
call Add_eol_whitespace_highlighting("markdown")
call Add_eol_whitespace_highlighting("ledger")
call Add_eol_whitespace_highlighting("lucius")
call Add_eol_whitespace_highlighting("php")
call Add_eol_whitespace_highlighting("puppet")
call Add_eol_whitespace_highlighting("purescript")
call Add_eol_whitespace_highlighting("python")
call Add_eol_whitespace_highlighting("ruby")
call Add_eol_whitespace_highlighting("scala")
call Add_eol_whitespace_highlighting("sh")
call Add_eol_whitespace_highlighting("vim")
call Add_eol_whitespace_highlighting("yaml")

" Make sure I can get spell checking when the file I am editing does not have
" a syntax associated with it.

" Python needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.py set expandtab
" maybe this could also be done with
autocmd FileType python set expandtab
" set autocomplete for python from the neocomplete plugin
"autocmd FileType python setlocal omnifunc=pythoncomplete#Complete

" Haskell also needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.hs setlocal expandtab
autocmd BufRead,BufNewFile *.lhs setlocal expandtab
" maybe this could also be done with
autocmd FileType haskell setlocal expandtab
" Set the indenter to hindent
" autocmd BufRead,BufNewFile *.hs setlocal formatprg=hindent
" autocmd FileType haskell setlocal formatprg=hindent
" Since formatprg is a global option (and not a global-local option), we have
" to do this dance to get formatprg be the correct value:
" https://groups.google.com/forum/#!msg/vim_dev/cFK1UjstyAk/mreb2H4VCtoJ
autocmd BufEnter *.hs set formatprg=hindent
autocmd BufLeave *.hs set formatprg=

autocmd FileType haskell setlocal tabstop=2
autocmd FileType haskell setlocal shiftwidth=2
autocmd FileType haskell setlocal softtabstop=2
autocmd BufRead,BufNewFile *.hs setlocal tabstop=2
autocmd BufRead,BufNewFile *.hs setlocal shiftwidth=2
autocmd BufRead,BufNewFile *.hs setlocal softtabstop=2

" hamlet files (for yesod) also need spaces instead of tabs
autocmd BufRead,BufNewFile *.hamlet set expandtab

" Cabal files also needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.cabal set expandtab
autocmd FileType cabal set expandtab
autocmd BufRead,BufNewFile *.cabal setlocal filetype=cabal

" SConscript and SConstruct files are python files
autocmd BufRead,BufNewFile SConstruct set ft=python
autocmd BufRead,BufNewFile SConscript set ft=python

" special settings for sas files
autocmd FileType sas set tabstop=3			" 3-space tab indent width
autocmd FileType sas set shiftwidth=3		" allows you to use < and > to indent/unindent blocks
autocmd FileType sas set softtabstop=3		" see multiple space characters as a tab

" settings for c#
autocmd FileType cs set omnifunc=syntaxcomplete#Complete
autocmd FileType cs set foldmethod=marker
autocmd FileType cs set foldmarker={,}
autocmd FileType cs set foldtext=substitute(getline(v:foldstart),'{.*','{...}',)
autocmd FileType cs set foldlevelstart=2

" settings for ruby
let ruby_no_expensive=1
autocmd FileType ruby setlocal tabstop=2
autocmd FileType ruby setlocal shiftwidth=2
autocmd FileType ruby setlocal softtabstop=2
autocmd FileType ruby setlocal expandtab
autocmd FileType ruby setlocal foldmethod=syntax

" settings for puppet
autocmd FileType puppet setlocal tabstop=2
autocmd FileType puppet setlocal shiftwidth=2
autocmd FileType puppet setlocal softtabstop=2
autocmd FileType puppet setlocal expandtab
autocmd FileType puppet setlocal foldmethod=indent

" settings for scala
autocmd FileType scala setlocal tabstop=2
autocmd FileType scala setlocal shiftwidth=2
autocmd FileType scala setlocal softtabstop=2
autocmd FileType scala setlocal expandtab
autocmd FileType scala setlocal foldmethod=indent

" settings for html
autocmd FileType html setlocal tabstop=2
autocmd FileType html setlocal shiftwidth=2
autocmd FileType html setlocal softtabstop=2
"autocmd FileType html setlocal expandtab
autocmd FileType html setlocal foldmethod=indent

let b:markdownFoldLevelInSyntaxBlock=0
" This function returns the appropriate indentation level for the current
" line.  It is used with the &foldexpr setting for markdown files.  It folds
" code blocks appropriately.
function! MarkdownFoldLevel()
	let h = matchstr(getline(v:lnum), '^\s*```')

	" If we are already in a markdown syntax block, and there is not "```" on
	" the current line, then just keep the indentation the same.
	if b:markdownFoldLevelInSyntaxBlock && empty(h)
		return "="
	endif


	" If we are already in a markdown syntax block, and there is a closing
	" "```" on the current line, then close the syntax block and decrease the
	" indentation by one.
	if b:markdownFoldLevelInSyntaxBlock && !empty(h)
		let b:markdownFoldLevelInSyntaxBlock=0
		return "s1"
	endif

	" If we are not already in a markdown syntax block, and there is an
	" opening "```" on the current line, then set that we are in a syntax
	" block and increase the indentation by one.
	if !empty(h)
		let b:markdownFoldLevelInSyntaxBlock=1
		return "a1"
	endif

	" If we are not in a markdown syntax block, and there is not a "```" on
	" the current line, then check if this is a header line, and increase the
	" indentation by that amount.
	let g = matchstr(getline(v:lnum), '^#\+')
	if empty(g)
		return "="
	else
		return ">" . len(g)
	endif
endfunction

" settings for markdown
autocmd BufNewFile,BufRead *.md set filetype=markdown
autocmd FileType markdown setlocal expandtab
autocmd FileType markdown setlocal foldexpr=MarkdownFoldLevel()
autocmd FileType markdown setlocal foldmethod=expr

" settings for nix files
autocmd BufRead,BufNewFile *.nix set expandtab
autocmd BufRead,BufNewFile *.nix set tabstop=2
autocmd BufRead,BufNewFile *.nix set shiftwidth=2
autocmd BufRead,BufNewFile *.nix set softtabstop=2
autocmd BufRead,BufNewFile *.nix setlocal commentstring=#%s
autocmd FileType nix set expandtab
autocmd FileType nix set tabstop=2
autocmd FileType nix set shiftwidth=2
autocmd FileType nix set softtabstop=2
autocmd FileType nix setlocal commentstring=#%s

" settings for ledger files
autocmd FileType ledger set expandtab

" settings for matlab files
autocmd FileType matlab setlocal commentstring=%%s

" settings for ocaml files.
" For some reason this doesn't work if we don't use "BufEnter".
" autocmd! BufRead,BufNewFile,BufEnter *.ml,*.mli,*mll,*.mly set filetype=ocaml

" settings for purescript files
autocmd FileType purescript set expandtab
autocmd FileType purescript set tabstop=2
autocmd FileType purescript set shiftwidth=2
autocmd FileType purescript set softtabstop=2
autocmd FileType purescript setlocal formatoptions+=1crq formatoptions-=t
autocmd FileType purescript setlocal commentstring=--%s
autocmd FileType purescript setlocal comments=:--

" settings for purescript files
autocmd FileType javascript set expandtab
autocmd FileType javascript set tabstop=2
autocmd FileType javascript set shiftwidth=2
autocmd FileType javascript set softtabstop=2

" settings for erlang files
autocmd FileType erlang set expandtab
autocmd FileType erlang set tabstop=2
autocmd FileType erlang set shiftwidth=2
autocmd FileType erlang set softtabstop=2

" settings for pug files
autocmd FileType pug set expandtab
autocmd FileType pug set tabstop=2
autocmd FileType pug set shiftwidth=2
autocmd FileType pug set softtabstop=2

"""""""""""""""""""""""""""
" OCaml Specific Settings "
"""""""""""""""""""""""""""

" Load in the merlin vim settings and ocp-indent settings.
if executable('opam')
	let g:opamshare = substitute(system('opam config var share'),'\n$','','''')

	" merlin
	let g:merlindir = g:opamshare . "/merlin/vim"
	if isdirectory(g:merlindir)
		execute "set rtp+=" . g:merlindir
		" This should get executed so that the merlin documentation is
		" available.
		" :execute "helptags " . g:opamshare . "/merlin/vim/doc"
	endif

	let g:ocpindentdir = g:opamshare . "/ocp-indent/vim"
	if isdirectory(g:ocpindentdir)
		" This needs to go on the front of the run time path so that it gets
		" loaded before the stock vim indentation files.
		execute "set rtp^=" . g:ocpindentdir
	endif
endif

"""""""""""""""""
" Extra Options "
"""""""""""""""""

" turn these on if you want to use vim over a slow link
"set lazyredraw
"set nottyfast

"""""""""""""""""
" Local Options "
"""""""""""""""""

" load a local .vimrc from "~/.vimrc-local" if it exists
let vimrc_dir = fnamemodify(expand($MYVIMRC), ":h")
let local_vimrc = vimrc_dir . "/.vimrc-local"
if filereadable(local_vimrc)
	execute "source " . local_vimrc
endif
