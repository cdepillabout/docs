filetype plugin on
filetype indent on

set fileencodings=utf-8
set encoding=utf-8
set ttymouse=xterm2		" mouse scrolling in vim
set mouse=a
set foldenable
set background=dark
set tabstop=4			" 4-space tab indent width
set shiftwidth=4		" allows you to use < and > to indent/unindent blocks
set softtabstop=4		" see multiple space characters as a tab
set shiftround			" Indent to nearest tab stop
set autoindent			" carries over previous indent to the next line
set smarttab			" A tab infront of a line inserts spaces or tabs according to expandtab

if version <= 702
	set switchbuf=usetab,useopen
else
	set switchbuf=usetab,useopen,newtab
endif

" Tell vim to remember certain things when we exit
"  '100 : marks will be remembered for up to 100 previously edited files
"  "100 : will save up to 100 lines for each register
"  :20 : up to 20 lines of command-line history will be remembered
"  % : saves and restores the buffer list
"  n... : where to save the viminfo files
set viminfo='100,\"100,:20,%,n~/.viminfo

set wildmode=list:longest	" When autocompleting things, do it like the shell
set wildmenu				" Autocomplete things on the menu?
set scrolloff=3				" Scroll when the cursor is 3 lines from top or bottom
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set ruler					" know how far you are in a file
set enc=utf-8
set fenc=utf-8
set fencs=iso-2022-jp,euc-jp,cp932
set backspace=indent,eol,start	" make sure backspace works correctly

set guifont=Bitstream\ Vera\ Sans\ Mono\ 14 "font names to be used in gui

" try to always use a syntax
syntax on

" this combination works out well to only apply case to searches
" if there is an uppercase letter in your search string
set ignorecase
set smartcase

" this uses the tags file if it is found anywhere above this directory
" in a file called tags.  If it can't find it, it then looks for a file
" called build/tags in any directory above this one
set tags+=tags;$HOME,build/tags;$HOME

" always show a tabline
set showtabline=2

colorscheme darkblue
"colorscheme default
"colorscheme delek
"colorscheme desert
"colorscheme torte

" highlight tab line differently
hi TabLine term=bold,reverse cterm=bold ctermfg=black ctermbg=white
hi TabLineFill term=bold,reverse cterm=bold ctermfg=white ctermbg=white
hi TabLineSel term=reverse ctermfg=white ctermbg=lightblue

" highlight the popup menu a little differently
hi PmenuSel ctermbg=lightblue

" make sure the normal background is black
hi Normal guibg=black


" settings specifically for java from 
" http://vimdoc.sourceforge.net/htmldoc/syntax.html
let java_highlight_java_lang_ids=1
let java_highlight_all=1
"let java_highlight_functions="style"
"let java_allow_cpp_keywords=1

" Minibufexplorer plugin settings
"let g:miniBufExplMapWindowNavVim = 1	" Let C-h, C-j, C-k, C-l move your 
										" current active buffer window
"let g:miniBufExplMapCTabSwitchBufs = 1	" Let C-TAB move to the next buffer and
										" C-SHIFT-TAB move to the previous
										" buffer
"let g:miniBufExplModSelTarget = 1		" Force minibufferexplorer to put
										" buffers in windows with 
										" non-modifiable buffers
										"

" make sure xml files are folded
let g:xml_syntax_folding=1

" make sure javascript files are folded
"let g:javaScript_fold=1

" use F5 for turning off and on hlsearch,
" in both input mode (imap?) and command mode (map?)
map <F5> :set hlsearch!<CR>
imap <F5> <ESC>:set hlsearch!<CR>a

" use F6 for turning on and off paste mode
map <F6> :set paste!<CR>
imap <F6> <ESC>:set paste!<CR>a

" use F7 for turning on and off list mode
map <F7> :set list!<CR>
imap <F7> <ESC>:set list!<CR>a

" use <C-h> and <C-l> to go forward and backward in tabs
" nnoremap just makes a normal mode mapping
nnoremap <C-h> gT
nnoremap <C-l> gt

" got to tab number (really only for gvim)
nnoremap <A-1> 1gt
nnoremap <A-2> 2gt
nnoremap <A-3> 3gt
nnoremap <A-4> 4gt
nnoremap <A-5> 5gt
nnoremap <A-6> 6gt
nnoremap <A-7> 7gt
nnoremap <A-8> 8gt
nnoremap <A-9> 9gt
nnoremap <A-0> 10gt

" use <C-Enter> to jump to the tag under the cursor in a new tab.
" Also check out "<C-w>T", it takes a split screen off to a new tab.
" THIS DOESN'T WORK FOR SOME REASON:
"nnoremap <C-{> <C-w><C-]><C-w>T
" this can also be something like this:
map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>


" F2 for turning on and off tag list
nnoremap <F2> :TlistToggle<CR>

" this is needed for running taglist in screen:
let Tlist_Inc_Winwidth = 0

" use CTRL-s for saving
" this doesn't work...
"nmap <c-s> :w<CR>
"imap <c-s> <Esc>:w<CR>a

" in input mode, what about we try using jj as escape
inoremap jj <Esc>

function! Resize(dir)
	" TODO: could also do something like this for horizontal split screen
	let above = 0
	let below = 0

	let this = winnr()

	if a:dir == 'C-J' || a:dir == 'C-K'
		execute "normal \<c-w>k"
		let up = winnr()
		if up != this
			execute "normal \<c-w>j"
			let above = 1
		endif

		execute "normal \<c-w>j"
		let down = winnr()
		if down != this
			execute "normal \<c-w>k"
			let below = 1
		endif

	"elseif '>' == a:dir || '<' == a:dir
	"	execute "normal \<c-w>h"
	"	let left = winnr()
	"	if left != this
	"		execute "normal \<c-w>l"
	"		let x = 'right'
	"	else
	"		let x = 'left'
	"	endif
	else
		echo "oops. check your ~/.vimrc here."
		return
	endif

	if ( ('C-J' == a:dir || 'C-K' == a:dir) && above == 0 && below == 0 )
		" this is the only window on the screen
		return 

	elseif ('C-J' == a:dir && above == 1 && below == 0)
		" there are no windows below this on the screen
		execute "normal 3\<c-w>-"
	elseif ('C-J' == a:dir && above == 0 && below == 1)
		" there are no windows below this on the screen but we are on the top
		execute "normal 3\<c-w>+"
	elseif ('C-K' == a:dir && above == 0 && below == 1)
		" there are no windows above this on the screen and we are on the top
		execute "normal 3\<c-w>-"
	elseif ('C-K' == a:dir && above == 1 && below == 0)
		" there are windows above this on the screen, and we are on the bottom
		execute "normal 3\<c-w>+"

	elseif ('C-J' == a:dir && above == 1 && below == 1) 
		" this is a middle window and we are trying to drop it down
		execute "normal \<c-w>j3\<c-w>-\<c-w>p"
	elseif ('C-K' == a:dir && above == 1 && below == 1)
		" this is a middle window and we are trying to raise it up
		execute "normal \<c-w>k3\<c-w>-\<c-w>p"

	else
		echo "oops. check your ~/.vimrc"
		return 
	endif
endfunction

" mappings for changing window size
nnoremap <silent> <C-J> :call Resize('C-J')<CR>
nnoremap <silent> <C-K> :call Resize('C-K')<CR>

" mappings for increasing window size when working
" with 3 or more splits
nnoremap + <C-W>+
nnoremap - <C-W>-

" I want to jump to the exact position in the line
nnoremap '' ``

" Open a bunch of tabs at once.  Also interpret globbing characters.
function Tabopen_all_files(...)
	let i = 1
	let firstnewtab = 0
	
	" loop over arguments passed to this function, both file names, new tab
	" names, and filename globs
	while i <= a:0
		let filelist = split(glob(a:{i}), "\n")

		if len(filelist) == 0
			" if there are no files in the glob, then we just pass it to
			" tabedit
			execute "tabedit " . a:{i}
			if i == 1
				let firstnewtab = tabpagenr()
			endif
		else
			" loop over files in the glob, opening each one
			let j = 0
			while j < len(filelist)
				execute "tabedit " . filelist[j]
				" if this is the first new tab that we're opening,
				" we have to save the tab number so we can come back here
				" after we're done opening all the other tabs
				if i == 1 && j == 0
					let firstnewtab = tabpagenr()
				endif
				let j = j + 1
			endwhile
		endif

		let i = i + 1
	endwhile

	" if we opened any tabs, then we need to go back to 
	" the first one we opened
	if firstnewtab
		execute "normal " . firstnewtab . "gt"
	endif
endfunction

" create a command ":Tabopen" that will call our tab-opening function
" and create an abbreviation for it with the name "tabo".  So, to use this
" just type ":tabo " and it will get replaced with ":Tabopen ".
command -nargs=+ -complete=file Tabopen call Tabopen_all_files(<f-args>)
cabbrev tabo Tabopen


" Convert all arguments to function from relative references to a file
" based on the file currently being edited, so absolute references based 
" on current working directory.
"
" For instance, if we are in /some/path/, and we are editing
" /some/path/src/nice.c, then if we call this with :tabopen join.c,
" the :tabopen function will get the argument src/join.c.
function RelativeFunc(function, ...)
	let file_basename = expand("%:p:h")
	let relativefiles = copy(a:000)

	let i = 0
	while i < len(relativefiles)
		"let relativefiles[i] = file_basename . "/" . relativefiles[i]
		let relativefiles[i] = substitute(file_basename . "/" . relativefiles[i], getcwd() . "/", "", "")
		let relativefiles[i] = simplify(relativefiles[i])
		let i = i + 1
	endwhile

	call call(a:function, relativefiles)
endfunction

" A complete function for completing file names relative to the current
" file being edited.  
"
" For instance, if we are in /some/path/, and we are editing
" /some/path/src/nice.c, if we try to complete a path using this func, 
" we will intially get a list of files in /some/path/src/, NOT /some/path/.
function RelativeFilesComplete(ArgLead, CmdLine, CursorPos)
	let file_basename = expand("%:p:h")
	let path = file_basename . "/" . a:ArgLead

	if isdirectory(path) && path[len(path) - 1] != "/"
		let path = path . "/"
	endif

	let relativefiles = split(glob(path . "*"), "\n")

	let index = 0
	while index < len(relativefiles)
		if isdirectory(relativefiles[index])
			let relativefiles[index] .= "/"
		endif
		let relativefiles[index] = substitute(relativefiles[index], file_basename . "/" , "", "")
		let index += 1
	endwhile

	return relativefiles
endfunction


command -nargs=+ -complete=customlist,RelativeFilesComplete 
			\ RelativeTabopen call RelativeFunc(function('Tabopen_all_files'), <f-args>)
cabbrev rt RelativeTabopen

" Execute the line under the cursor.
"function! ExecuteLine()
"	let thisline = getline('.')
"	execute '!' . thisline
"endfunction
"nnoremap <silent> <C-R> :call ExecuteLine()<CR>

" use command VGrep to list files in a vertical split. The '!' after grep
" makes the command not jump to the first occurance that was found.
command! -nargs=+ Vgrep execute 'silent grep! <args>' | vert copen 30
command! -nargs=+ Vlgrep execute 'silent lgrep! <args>' | vert copen 30
" use command Grep to list files in a new tab
command! -nargs=+ Grep execute 'silent grep! <args>' | tab copen
command! -nargs=+ LGrep execute 'silent lgrep! <args>' | tab copen

" Autocommand to change what <CR> does on quickfix buffer.
" (It changes <CR> to open the first result in a new tab).
autocmd BufWinEnter * if &buflisted && &filetype == "qf" | noremap <buffer> <CR> <CR><C-W>T| endif

" source ~/.vim/plugin/cscope_maps.vim
" source ~/.vim/syntax/javascript.vim

" show when autocmds are called
"set verbose=9


""""""""" This uses the execute command to create an autocmd 
""""""""" that sets the fold_method if the syntax matches.
""""""""" You have to use execute so that the variables get
""""""""" evaluated now instead of when the autocmd executes.

function Add_auto_foldmethod(syntax_of_file, fold_method)
	execute "autocmd Syntax * "
		\ "if expand(\"<amatch>\") == \"" . a:syntax_of_file . "\" | "
		\ "execute \"set foldmethod=" . a:fold_method . "\" | "
		\ " endif "
endfunction

call Add_auto_foldmethod("c", "syntax")
call Add_auto_foldmethod("cpp", "syntax")
"call Add_auto_foldmethod('asm', 'indent')
call Add_auto_foldmethod("java", "syntax")
call Add_auto_foldmethod("python", "indent")
call Add_auto_foldmethod("css", "indent")
call Add_auto_foldmethod("sas", "syntax")
call Add_auto_foldmethod("xml", "syntax")
call Add_auto_foldmethod("xsd", "syntax")
call Add_auto_foldmethod("ant", "syntax")
call Add_auto_foldmethod("javascript", "indent")

" Make sure I can get spell checking when the file I am editing does not have
" a syntax associated with it.

" Python needs spaces instead of tabs.
autocmd BufRead,BufNewFile *.py set expandtab
" maybe this could also be done with
"autocmd FileType python set expandtab

" special settings for sas files
autocmd FileType sas set tabstop=3			" 3-space tab indent width
autocmd FileType sas set shiftwidth=3		" allows you to use < and > to indent/unindent blocks
autocmd FileType sas set softtabstop=3		" see multiple space characters as a tab

" Make vim jump to the last position that you were editing in the file.
" When we reload, tell vim to restore the cursor to the saved position.
" This long, ugly thing is needed because funny things happen when you 
" use folding.
augroup JumpCursorOnEdit
 au!
 autocmd BufReadPost *
 \ if expand("<afile>:p:h") !=? $TEMP |
 \ if line("'\"") > 1 && line("'\"") <= line("$") |
 \ let JumpCursorOnEdit_foo = line("'\"") |
 \ let b:doopenfold = 1 |
 \ if (foldlevel(JumpCursorOnEdit_foo) > foldlevel(JumpCursorOnEdit_foo - 1)) |
 \ let JumpCursorOnEdit_foo = JumpCursorOnEdit_foo - 1 |
 \ let b:doopenfold = 2 |
 \ endif |
 \ exe JumpCursorOnEdit_foo |
 \ endif |
 \ endif
 " Need to postpone using "zv" until after reading the modelines.
 autocmd BufWinEnter *
 \ if exists("b:doopenfold") |
 \ exe "normal zv" |
 \ if(b:doopenfold > 1) |
 \ exe "+".1 |
 \ endif |
 \ unlet b:doopenfold |
 \ endif
augroup END


" turn these on if you want to use vim over a slow link
"set lazyredraw
"set nottyfast
