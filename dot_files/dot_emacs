;; -*- mode: emacs-lisp; -*-

;; Make sure we can load packages.
(require 'package)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

(setq package-enable-at-startup nil)
(package-initialize)

;; Load the "use-package" package manager if does not already exist.
(unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

;; Packages to use.
(setq package-selected-packages
      '(dockerfile-mode
        evil
        evil-commentary
        evil-leader
        evil-magit
        evil-org
        evil-surround
        haskell-mode
        helm
        helm-projectile
        magit
        nix-mode
        org-roam
        projectile
        purescript-mode
        racket-mode
        undo-tree
        use-package
        yaml-mode
        ))

(eval-when-compile
    (require 'use-package))

;; Here are some settings for displaying any sort of new buffer in a
;; new tab.  However, this doesn't work well for things like `help'
;; and `magit-status', so it can't be set by default.
;; (setq display-buffer-overriding-action '(display-buffer-in-tab))
;; (setq display-buffer-base-action '(display-buffer-in-tab))

(defun run-in-new-tab (fun &rest args)
  "Run a given function FUN in a new tab and pass it the supplied ARGS."
  (tab-bar-new-tab)
  (apply fun args)
  )

(defun magit-status-in-tab (&optional directory cache)
  "Run `magit-status' in a new tab."
  ;; This takes the interactive value directly from magit-status.
  (interactive (eval (cadr (interactive-form 'magit-status))))
  (let ((magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
    (run-in-new-tab 'magit-status directory cache)))

(defun take-window-to-new-tab ()
  "Take a window to a new tab, closing the window in the existing tab."
  (interactive)
  (let ((buffer (current-buffer)))
    (delete-window)
    (tab-bar-new-tab)
    (switch-to-buffer buffer)))

(use-package dockerfile-mode
  :ensure t
  :defer t
  )

(use-package evil-leader
  :ensure t
  :init
  ;; global-evil-leader-mode needs to be called before evil is
  ;; initialized.
  (global-evil-leader-mode)
  (evil-leader/set-leader "<SPC>")
  (evil-leader/set-key "gs" 'magit-status-in-tab)
  (evil-leader/set-key "wgs" 'magit-status)
)

;; Load evil.
(use-package evil
  :ensure t

  ;; Code to run before evil is loaded.
  :init

  ;; Use evil's built-in search instead of emac's default isearch.
  (setq evil-search-module 'evil-search)

  ;; Code to run after evil is loaded.
  :config

  ;; Evil - Packages

  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode))

  (use-package evil-magit
    :ensure t
    :config
    ;; Make sure that "q" correctly quits in magit-status, instead of
    ;; just switching back to the old buffer.
    (evil-magit-define-key 'normal 'magit-mode-map "q" 'my-quit)
    (evil-magit-define-key 'normal 'magit-mode-map "Q" 'magit-mode-bury-buffer)
    )

  (use-package evil-commentary
    :ensure t
    :config
    (setq evil-commentary-mode t)
    )

  ;; Evil - Additional Options

  ;; Enable evil mode.  This needs to come after the evil- packages
  ;; above, since they may add hooks that need to get run when
  ;; evil-mode is enabled. See
  ;; https://emacs.stackexchange.com/questions/30332/evil-leader-stops-working-when-i-eval-buffer.
  (evil-mode 1)

  ;; This makes it so that "*" key searches for full symbols
  ;; (including - and _ in variable names).
  (setq evil-symbol-word-search t)

  ;; Evil - Functions

  (defun insert-space-above (count)
    (interactive "p")
    (dotimes (_ count) (save-excursion (evil-insert-newline-above))))

  (defun insert-space-below (count)
    (interactive "p")
    (dotimes (_ count) (save-excursion (evil-insert-newline-below))))

  (defun move-tab-back ()
    (interactive)
    (tab-bar-move-tab -1))

  (defun move-tab-forward ()
    (interactive)
    (tab-bar-move-tab 1))

  (defvar tabo-cwd default-directory
    "The directory to use as the relative directory for the :tabo
    command.")

  (defun tabo-completion-file-name-table (string pred action)
    "Completion table for file names relative to `tabo-cwd'."
    (let ((default-directory tabo-cwd))
      (completion-file-name-table string pred action)))

  (defalias 'tabo-completion--file-name-table
    (completion-table-with-quoting #'tabo-completion-file-name-table
                                   #'substitute-in-file-name
                                   #'completion--sifn-requote)
    "This is basically `completion--file-name-table' from
minibuffer.el in the emacs source code."
    )

  (evil-ex-define-argument-type tabo-file
    "Handles a tabo file argument."
    :collection tabo-completion--file-name-table)

  (evil-define-interactive-code "<tf>"
    "Ex mode :tabo file argument."
    :ex-arg tabo-file
    (list (when (evil-ex-p) evil-ex-argument)))

  (evil-define-command my-tabo (filename)
    "Open a file in a new tab."
    :repeat nil
    (interactive "<tf>")
    (let ((full-path (expand-file-name filename tabo-cwd)))
        (my-rt full-path))
    )

  (evil-define-command my-pwd-ex-cmd
    "Show the current `tabo-cwd' value.  This is used in the
:tabo and :my-cd ex commands."
    (interactive)
    (message "%s" tabo-cwd))

  (evil-define-command my-cd-ex-cmd (path)
    "Set `tabo-cwd' to a new path.  This affects the relative
path used for the :tabo command."
    :repeat nil
    (interactive "<tf>")
    (let ((new-path (expand-file-name path tabo-cwd)))
        (setq tabo-cwd new-path))
    )

  (evil-define-command my-rt (filename)
    "Open a file in a new tab. This starts completion relative to
the file opened in the currently focused buffer."
    :repeat nil
    (interactive "<f>")
    (let ((value (find-file-noselect filename nil nil t)))
      ;; (message "my-tabo, value: %s, nreverse value: %s" value (nreverse value))

      ;; TODO: If the filename passed to find-file-noselect contains
      ;; wildcards, then value is returned as a list.  However, extra
      ;; files are opened as buffers, not tabs.  This should be modified
      ;; to instead open ALL files returned as tabs.
      (if (listp value)
        (progn
          (setq value (nreverse value))
          (switch-to-buffer-other-tab (car value))
          (mapc 'switch-to-buffer (cdr value))
          value)
        (switch-to-buffer-other-tab value))
      )
    )

  (evil-define-command my-quit
    "Close the current window.  Close the tab if the last window in
the tab was closed.  Run `evil-quit' if the last tab was closed."
    (interactive)
    (let* ((current-window (selected-window))
           (total-visible-windows (length (window-list)))
           (all-tabs (tab-bar-tabs))
           (total-tabs (length all-tabs)))
      (if (> total-visible-windows 1)
          (delete-window)
        (if (> total-tabs 1)
            (tab-bar-close-tab)
          (evil-quit)))))

  (evil-define-command load-dot-emacs
    "Reload the .emacs file."
    (interactive)
    (load-file user-init-file))

  ;; Evil - Key Mappings

  ;; Evil keys for org-mode in normal mode.
  (evil-define-key 'normal org-mode-map
    (kbd "TAB") 'org-cycle
    (kbd ",A") 'org-archive-subtree
    (kbd ",a") 'org-agenda
    (kbd ",G") 'org-clock-goto
    (kbd ",I") 'org-clock-in
    (kbd ",O") 'org-clock-out
    (kbd ",t") 'org-todo
  )

  ;; Evil keys for org-mode in insert mode.
  (evil-define-key 'insert org-mode-map
    (kbd "M-h") 'org-metaleft
    (kbd "M-j") 'org-metadown
    (kbd "M-k") 'org-metaup
    (kbd "M-l") 'org-metaright
  )

  ;; Evil keys for org-roam in normal mode.
  (evil-define-key 'normal org-roam-mode-map
    (kbd ",ri") 'org-roam-insert
  )

  ;; Evil keys for org-roam in insert mode.
  (evil-define-key 'insert org-roam-mode-map
    (kbd "C-c i") 'org-roam-insert
  )

  ;; Evil keys for markdown mode.
  (evil-define-key 'normal markdown-mode-map
    (kbd "TAB") 'markdown-cycle)

  ;; Global evil mappings.
  (evil-define-key nil evil-normal-state-map
    ;; Switch to other-buffer.
    (kbd "SPC TAB") 'mode-line-other-buffer

    ;; Insert space above or below.
    (kbd "[ SPC") 'insert-space-above
    (kbd "] SPC") 'insert-space-below

    ;; Move around tabs.
    (kbd "C-h") 'tab-bar-switch-to-prev-tab
    (kbd "C-l") 'tab-bar-switch-to-next-tab
    (kbd "C-y") 'move-tab-back
    (kbd "C-u") 'move-tab-forward

    ;; Use Q to record macros, and q to quit.
    (kbd "Q") 'evil-record-macro
    (kbd "q") 'my-quit

    ;; Use ,u for the universal argument.
    (kbd ",u") 'universal-argument

    ;; F-X commands
    (kbd "<f5>") 'evil-ex-nohighlight
    (kbd "<f7>") 'whitespace-mode

    ;; org-roam commands that can be used in any buffer.
    (kbd ",rr") 'org-roam
    (kbd ",rc") 'org-roam-capture
    (kbd ",rf") 'org-roam-find-file
    (kbd ",wrf") 'org-roam-find-file-window

    ;; projectile with helm
    (kbd ",pf") 'helm-projectile-find-file
    (kbd ",pg") 'helm-projectile-grep

    ;; Reload ~/.emacs
    (kbd ",l") 'load-dot-emacs

    ;; Show Help
    (kbd ",h") 'help
    )

  ;; Ex commands
  (evil-ex-define-cmd "rt" 'my-rt)
  (evil-ex-define-cmd "tabo" 'my-tabo)
  (evil-ex-define-cmd "my-cd" 'my-cd-ex-cmd)
  (evil-ex-define-cmd "my-pwd" 'my-pwd-ex-cmd)
  )

(use-package evil-org
  :ensure t
  :after org
  :hook ((org-mode . evil-org-mode)
         (evil-org-mode . evil-org-set-key-theme))
  :config
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))


;; Load haskell-mode.
(use-package haskell-mode
  :ensure t
  :defer t
  :hook (haskell-mode
         . (lambda ()
             ;; Make sure the '>>' key in evil mode only indents by
             ;; two spaces.
             (setq evil-shift-width 2)
             ))
  :config
  ;; This gives no indentation before where, which isn't good.
  ;; I don't know why I originally set this.
  ;; (setq haskell-indentation-where-pre-offset 0)
  )

(use-package helm
  :ensure t
  :config
  ;; When running the helm buffer list commands (like
  ;; `helm-buffers-list'), use RET to open a new tab (instead of
  ;; opening the buffer in the current window).
  ;;
  ;; TODO:
  ;;
  ;; - I would ideally also like to be able to run C-x b and use Helm,
  ;;   but have it open a buffer in the current window, instead of
  ;;   create a new tab.
  ;;
  ;; - When I create a NEW buffer with `helm-buffers-list', it opens
  ;;   the new buffer in the current window instead of opening it in a
  ;;   new tab.
  (with-eval-after-load "helm-buffers"
    (define-key helm-buffer-map (kbd "<RET>") #'helm-buffers-switch-to-buffer-new-tab))

  ;; Remap the C-x t b command to use Helm.
  (define-key tab-prefix-map "b" 'helm-buffers-list)
  )

(use-package helm-grep
  :preface
  (defun my-helm-grep-run-other-tab-action ()
    "Run grep goto other frame action from `helm-do-grep-1'."
    (interactive)
    (with-helm-alive-p
      ;; TODO: need to setup my-helm-grep-other-tab as action
      (message "my-helm-grep-run-other-tab-action, helm-grep-actions %S" helm-grep-actions)
      (helm-exit-and-execute-action 'my-helm-grep-other-tab)))

  (defun my-helm-grep-other-tab (candidate)
    "Jump to result in other frame from helm grep."
    ;; Required for `flet'.
    (require 'cl)
    (message "YO IN RET FROM helm-grep-map")
    (flet ((find-file-other-frame (fname) (message "called find-file-other-frame %s" fname)))
      (helm-grep-action candidate 'other-frame)))

  ;; (setq helm-grep-actions (cons '("Find file other tab" . 'my-helm-grep-other-tab) helm-grep-actions))
  :init

  (eval-after-load "helm-grep"
    '(progn
       (setq helm-grep-actions
             (append helm-grep-actions
                     '(("Tab tab tab" . my-helm-grep-other-tab))))))
  )

  ;; ;; When in `helm-projectile-grep' menu, RET opens a file in a new
  ;; ;; tab.
  ;; ;; (define-key helm-grep-map (kbd "<RET>") #'my-helm-find-file-other-tab)
  ;; (define-key helm-grep-map (kbd "<RET>") 'my-helm-grep-run-other-tab-action)

(use-package helm-projectile
  :ensure t
  :init
  ;;
  ;; (setq helm-grep-actions (cons '("Find file other tab" . my-helm-grep-other-tab) helm-grep-actions))
  ;; (setq helm-grep-actions
  ;;       (helm-make-actions
  ;;        "Find File" 'helm-grep-action
  ;;        "Find file other frame" 'helm-grep-other-frame
  ;;        "Save results in grep buffer" 'helm-grep-save-results
  ;;        "Find file other window (C-u vertically)" 'helm-grep-other-window
  ;;        "Find file other tab" 'my-helm-grep-other-tab
  ;;        ))


  ;; (eval-after-load "helm-grep"
  ;;   '(progn
  ;;      (setq helm-grep-actions
  ;;            (append helm-grep-actions
  ;;                    '(("Tab tab tab" . my-helm-grep-other-tab))))))
  :config

  ;; When in `helm-projectile-find-file' menu, RET opens a file in a
  ;; new tab.
  (define-key helm-projectile-find-file-map (kbd "<RET>") #'helm-ff-find-file-other-tab)


;;   (defun my-helm-grep-other-tab (candidate)
;;     "Jump to result in other frame from helm grep."
;;     (helm-grep-action candidate 'other-frame))

;;   (defun my-helm-grep-run-other-tab-action ()
;;     "Run grep goto other frame action from `helm-do-grep-1'."
;;     (interactive)
;;     ;; Required for `flet'.
;;     (require 'cl)
;;     (flet ((
;; (flet ((my-xxx () (message "THIS IS NEW THING")))
;;   (my-using-my-xxx))
;;     (with-helm-alive-p

;;       (helm-exit-and-execute-action 'my-helm-grep-other-tab)))
  (defun my-helm-grep-run-other-tab-action ()
    "Run grep goto other frame action from `helm-do-grep-1'."
    (interactive)
    (with-helm-alive-p
      ;; TODO: need to setup my-helm-grep-other-tab as action
      (message "my-helm-grep-run-other-tab-action, helm-grep-actions %S" helm-grep-actions)
      (helm-exit-and-execute-action 'my-helm-grep-other-tab)))

  (defun my-helm-grep-other-tab (candidate)
    "Jump to result in other frame from helm grep."
    ;; Required for `flet'.
    (require 'cl)
    (message "YO IN RET FROM helm-grep-map")
    ;; TODO: This is finally working!!  Need to clean all this up!
    (flet ((find-file-other-frame (fname) (message "called find-file-other-frame %s" fname)))
      (helm-grep-action candidate 'other-frame)))

  (setq helm-grep-actions (cons '("Find file other tab" . my-helm-grep-other-tab) helm-grep-actions))
  (setq helm-projectile-grep-or-ack-actions (append '("Find file other tab"  my-helm-grep-other-tab) helm-projectile-grep-or-ack-actions))

  ;; ;; When in `helm-projectile-grep' menu, RET opens a file in a new
  ;; ;; tab.
  ;; ;; (define-key helm-grep-map (kbd "<RET>") #'my-helm-find-file-other-tab)
  (define-key helm-grep-map (kbd "<RET>") 'my-helm-grep-run-other-tab-action)

    ;; (lambda ()
    ;;   (interactive)
    ;;   ;; Required for `flet'.
    ;;   (require 'cl)
    ;;   (message "YO IN RET FROM helm-grep-map")
    ;;   (flet ((find-file-other-frame (fname) (message "called find-file-other-frame %s" fname)))
    ;;     (helm-grep-run-other-frame-action))))
  )

(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  ;; Don't ever use tabs for indentation in markdown-mode.
  :hook (markdown-mode . (lambda () (setq indent-tabs-mode nil)))
  :init
  (setq markdown-command "multimarkdown")
  )

;; Load magit.
(use-package magit
  :ensure t
  :defer t
  :config

  ;; Styling for the current HEAD git branch.  This is needed because
  ;; by default it is styled with a single box around it in the GUI,
  ;; but that doesn't show up in the CLI.
  ;;
  ;; `face-spec-set' is the function to use to set different a
  ;; different face style depending on whether we are in the GUI or on
  ;; console.
  (face-spec-set 'magit-branch-current
    '(
      ( ;; Only apply this style when we are in the console
       ((type tty))
       (:inherit magit-branch-local
        :foreground "yellow"
        :weight extra-bold
        )
      )
      ( ;; Apply this style in all other cases (not in console)
       t
       (:inherit magit-branch-local :box 1)
      )
     )
    )

  ;; Make sure magit will prune when fetching.
  (setq magit-fetch-arguments '("--prune"))

  ;; Make sure magit will give us pretty graphs when viewing the log.
  (setq magit-log-arguments '("--graph" "--color" "--decorate" "-n256"))

  (defun pick-git-exe ()
    "Pick a command to use for git.  Use emacs-git-gas if it is available.
However, calling emacs-git-gas appears to be very slow for some reason,
so only use this if we opening emacs over an SSH session."
    (let ((ssh-conn-env-var (getenv "SSH_CONNECTION"))
          (my-git-exe (executable-find "emacs-git-gas")))
      (if (and ssh-conn-env-var my-git-exe) my-git-exe "git")))

  (setq magit-git-executable (pick-git-exe))

  (defun my-magit-commit-update ()
    "Run git commit with a message of update."
    (interactive)
    (magit-commit-create '("--message" "update")))

  (defun my-magit-commit-wip ()
    "Run git commit with a message of wip."
    (interactive)
    (magit-commit-create '("--message" "wip")))

  ;; Add a magit-commit command for creating commit with commit
  ;; message "wip".
  (transient-append-suffix 'magit-commit "c"
     '("z" "Commit with msg \"wip\"" my-magit-commit-wip))

  ;; Add a magit-commit command for creating commit with commit
  ;; message "update".
  (transient-append-suffix 'magit-commit "c"
    '("u" "Commit with msg \"update\"" my-magit-commit-update))
  )

;; Load nix-mode
(use-package nix-mode
  :ensure t
  :defer t
  )

;; Load purescript-mode.
(use-package purescript-mode
  :ensure t
  :defer t
  :config
  (add-hook 'purescript-mode-hook 'turn-on-purescript-indentation)
  )

(use-package projectile
  :ensure t
  :config
  (setq projectile-use-git-grep t)
  )

;; This is necessary for "redo" functionality in evil-mode.
(use-package undo-tree
  :ensure t
  :init
  (global-undo-tree-mode 1)

  ;; This is needed to get "redo" functionality working in evil-mode.
  ;;
  ;; Note that this can changed in emacs 28 to `\'undo-redo', which is
  ;; built-in to emacs 28.  See the documentation on
  ;; `evil-undo-system'.  If this is setup, then this use-package for
  ;; undo-tree can be removed.
  (setq evil-undo-system 'undo-tree)
  ;; I don't know why this is needed, but I needed this as well:
  (evil-set-undo-system 'undo-tree)
  )

(use-package yaml-mode
  :ensure t
  :defer t
  )

;;;;;;;;;;;;;;;;;;;
;; Other options ;;
;;;;;;;;;;;;;;;;;;;

;; Don't show the startup screen.
(setq inhibit-startup-screen t)

;; Always follow symlinks when opening files.  This helps with making sure
;; that we are editing files in projects.  Especially dot files.
(setq vc-follow-symlinks nil)

;; This is similar to vim's scrolloff.  It makes the screen scroll when you
;; are 3 lines from the top or bottom.
(setq scroll-margin 3)

;; Make sure that shift-insert will actually insert what is on the X
;; clipboard.
(setq select-enable-primary t)

;; Smooth scrolling like vim.  Without scroll-conservatively, emacs still
;; sometimes jumps the cursor around the screen when scrolling up.
(setq scroll-step 1)
(setq scroll-conservatively 1000)

;; Make sure the column number is always shown.
(setq column-number-mode t)

;; Set the global default value of buffer-local variables.
(setq-default
  ;; Always show trailing whitespace.
  ;; TODO: This shouldn't be enabled for all buffers, but just for select
  ;; buffers (including org-mode).
  show-trailing-whitespace t
)

;; Show matching parentheses.
(show-paren-mode 1)

;; Disable the menu bar.
(menu-bar-mode -1)

;; If we are using graphical emacs, disable the tool bar and the scroll bar.
(if window-system
  (progn
    (tool-bar-mode -1)
    (scroll-bar-mode -1)))

;; Enable Tab Bar Mode.
(setq tab-bar-show t)

;; Don't show the close button on tabs.
(setq tab-bar-close-button-show nil)

(defun tab-bar-tab-name-truncated-show-modified ()
  "Similar to `tab-bar-tab-name-truncated', but also show if the
buffer in the tab has currently been modified and needs saving."
  (let ((tab-name-ellipsized (tab-bar-tab-name-truncated))
        (buffer (window-buffer (minibuffer-selected-window))))

    (if (and (buffer-modified-p buffer)
             (not (string-prefix-p "*" (buffer-name buffer))))
        (concat "+ " tab-name-ellipsized)
      tab-name-ellipsized)))

;; Set the function that displays the file name in the tab bar.
(setq tab-bar-tab-name-function #'tab-bar-tab-name-truncated-show-modified)

;; Show 35 characters of the tab-bar name before truncating it.
(setq tab-bar-tab-name-truncated-max 35)

;; Hooks to add to emacs lisp mode.
(add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	    ;; Make sure that tabs are never used.  Spaces are used
	    ;; for indentation.
	    (setq indent-tabs-mode nil)))

;; Only allow the space allocated for line numbers in a file to grow
;; wider, never shrink, even if you scroll up to where line numbers
;; are less than 100.
(setq display-line-numbers-grow-only t)

;; Calculate the max line number width when opening a file by counting
;; all the lines in the file.  This is slow, but along with
;; `display-line-numbers-grow-only' it prevents a weird bug where the
;; current line number gets an extra space before and makes it jump
;; around:
;; https://lists.gnu.org/archive/html/bug-gnu-emacs/2017-09/msg00743.html
(setq display-line-numbers-width-start t)

;; Display line numbers for each window.
(global-display-line-numbers-mode)

;; Don't create lockfiles that start with '.#'.  This is slightly unsafe, but
;; having those files around is very annoying.
(setq create-lockfiles nil)

;; Make sure the backup files go to a specific directory.
(setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))

;; Completions are ordered in vertical columns instead of horizontal rows
(setq completions-format 'vertical)

;; When opening files that are softlinks, open the actual file (not the softlink).
;; This is necessary so that when I edit .emacs, Magit knows that it is actually
;; looking at ~/docs/dot_emacs, so it should look for the Git repo in ~/docs.
(setq find-file-visit-truename t)

;;;;;;;;;;;;;;;;;;;;;;
;; Colors and Fonts ;;
;;;;;;;;;;;;;;;;;;;;;;

(load-theme 'manoj-dark)

;; Set the default font.
(set-face-attribute 'default nil
  :family "Source Code Pro"
  :height 140
  :weight 'normal
  :width 'normal)

;; Set the cursor color to red to match Vim in the terminal.
(set-cursor-color "red")

;; Set the EOL whitespace to be colored in white.
(set-face-attribute 'trailing-whitespace nil
   :background "white")

;; Set the default font for Japanese characters.
(set-fontset-font t 'japanese-jisx0208 (font-spec :family "IPAPGothic"))

;; Style the tab-bar so it looks like my Vim tab-bar.
(set-face-attribute 'tab-bar nil
  :background "white"
  :foreground "black")
(set-face-attribute 'tab-bar-tab nil
  :background "deep sky blue"
  :foreground "white"
  :box 'nil
  :weight 'bold)
(set-face-attribute 'tab-bar-tab-inactive nil
  ;; :background "deep sky blue"
  :foreground "black"
  :box 'nil
  :weight 'normal
  )

(with-eval-after-load "org"
  (if (display-graphic-p)

    ;; faces to set if we are in the GUI
    (progn
      (set-face-attribute 'org-level-2 nil :foreground "dark goldenrod" :weight 'bold)
      (set-face-attribute 'org-level-3 nil :foreground "firebrick" :weight 'bold)
      (set-face-attribute 'org-special-keyword nil :foreground "light gray" :weight 'light)
      (set-face-attribute 'org-date nil :foreground "dark magenta" :underline nil :weight 'normal)
      (set-face-attribute 'org-tag nil :foreground "cornflower blue" :weight 'light)
    )

    ;; faces to set if we are in the CUI
    (set-face-attribute 'org-level-2 nil :foreground "color-116" :weight 'bold)
    (set-face-attribute 'org-level-3 nil :foreground "color-41" :weight 'bold)
    (set-face-attribute 'org-level-4 nil :weight 'bold)
    (set-face-attribute 'org-level-5 nil :weight 'bold)
    (set-face-attribute 'org-special-keyword nil :foreground "color-95" :weight 'light)
  )
)

;;;;;;;;;;;;;;;;;;;;;;
;; Org-mode options ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Make sure org files are always indented.
(setq org-startup-indented t)

;; Make sure that org files wrap long lines (so they don't scroll off
;; the side of the screen).
;;
;; This is generally what I want, but it doesn't look good for tables
;; to be wrapped.  If I want to view a table clearly, I should use the
;; command `toggle-truncate-lines' in an org file.
(setq org-startup-truncated nil)

;; Make sure that we can perform command when selecting blocks of text in
;; visual mode in org mode.
(setq org-support-shift-select t)

;; Always use org-agenda-log-mode in new agenda views. Can be toggled with
;; 'L'.
(setq org-agenda-start-with-log-mode t)

;; Always use org-agenda-clockreport-mode in new agenda views. Can be toggled
;; with 'R'.
(setq org-agenda-start-with-clockreport-mode t)

;; Don't use the org-agenda time grid.
(setq org-agenda-use-time-grid nil)

;; Make sure the task that is currently being clocked is shown in the clock
;; report.
(setq org-clock-report-include-clocking-task t)

;; Make sure that '_' and '^' are not interpreted as sub and super scripts in
;; org-mode unless the value is surrounded with {}.
(setq org-use-sub-superscripts '{})

;; Any time an entry is turned from TODO to DONE, a CLOSED timestamp
;; will be inserted just after the headline.
(setq org-log-done 'time)

;; When storing a link to an Org file, use an entry ID property
;; (instead of just a headline).
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

;; Set the latex options for rendering equations in org-mode when
;; using the preview with C-c C-x C-l.
(setq
 org-format-latex-options
 '(:foreground default :background default :scale 2.25
   :html-foreground "Black" :html-background "Transparent" :html-scale 2.0
   :matchers ("begin" "$1" "$" "$$" "\\(" "\\[")))

;; Setup org-roam directory
(setq org-roam-directory "~/gtd/roam")

;; Make sure helm is used as the completion system for org-roam.
(setq org-roam-completion-system 'helm)

;; Make org-roam-find-file open files in a new tab.
(setq org-roam-find-file-function 'find-file-other-tab)

(defun org-roam-find-file-window ()
  "Just like `org-roam-find-file', but set
`org-roam-find-file-function' so that the new file pops up in a
window instead of a tab."
  (interactive)
  (let ((org-roam-find-file-function 'find-file-other-window))
    (org-roam-find-file)))

;; Make org-roam-find-file open files in a new tab.
(setq org-roam-find-file-function 'find-file-other-tab)

;; Set a capture template that also provides space for roam aliases
;; and links to other notes.
(setq org-roam-capture-templates
  '(("d" "default" plain (function org-roam-capture--get-point)
     "%?"
     :file-name "%<%Y%m%d%H%M%S>-${slug}"
     :head "#+title: ${title}\n#+roam_alias:\nlinks:\n\n"
     :jump-to-captured t
     :unnarrowed t)))

(defun my-initialize-org-roam ()
  "Enable `org-roam-mode' if ~/gtd/roam exists."
  (when (file-directory-p "~/gtd/roam")
    (org-roam-mode)))

;; Enable a global org-roam-mode minor mode.
(add-hook 'after-init-hook 'my-initialize-org-roam)

;; Setup my GTD stuff.
(with-eval-after-load "org"
  (when (file-directory-p "~/gtd")

    ;; Set which files are checked for agendas.
    (setq
     org-agenda-files
     '("~/gtd/projects.org"
       "~/gtd/projects.org_archive"))

    ;; Define capture templates for use with org-capture.
    (setq
     org-capture-templates
     '(("t"
        "Todo [inbox]"
        entry
        (file+headline "~/gtd/inbox.org" "Inbox")
        "* TODO %i%?")
       ("T"
        "Tickler"
        entry
        (file+headline "~/gtd/tickler.org" "Tickler")
        "* %i%? \n %U")))

    ;; Open up the org-capture buffer in a new tab.
    ;; I use this for the org-roam capture buffer.
    (add-hook 'org-capture-mode-hook 'take-window-to-new-tab)

    ;; Create the refile targets for moving around tasks.
    (setq
     org-refile-targets
     '(("~/gtd/projects.org" :maxlevel . 3)
       ("~/gtd/someday.org" :level . 1)
       ("~/gtd/tickler.org" :maxlevel . 2)))

    ;; Setup the todo keywords.
    ;;
    ;; "TODO"      -- The task has yet to be done.
    ;; "NEXT"      -- The task is the next to be done in the current project
    ;;                (or is currently being done).
    ;; "WAITING"   -- I am waiting for someone else to finish something or
    ;;             -- get back to me before I continue with this task.
    ;; "ONHOLD"    -- This task is on hold for some other reason and will not
    ;;             -- be worked on.  I may be trying to figure out whether or
    ;;             -- not it will ever be done.
    ;; "DONE"      -- The task has been finished.
    ;; "CANCELLED" -- The task has been cancelled and will not be done.
    (setq
     org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "WAITING(w)" "ONHOLD(o)" "|" "DONE(d)" "CANCELLED(c)")))

    ;; Setup the default column format if it doesn't appear in the file.
    (setq
     org-columns-default-format
     "%4TODO %55ITEM(Task) %7Effort(Effort){:} %7CLOCKSUM(Clock){:} %TAGS")

    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Default Emacs stuff ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(helm-grep-actions
   '(("Find File" . helm-grep-action)
     ("Find file other frame" . helm-grep-other-frame)
     ("Save results in grep buffer" . helm-grep-save-results)
     ("Find file other window (C-u vertically)" . helm-grep-other-window)
     ("tab stuff whoooooo" . my-helm-grep-other-tab))))

(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 )
